[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "",
    "text": "1 About",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.1 Welcome",
    "text": "1.1 Welcome\nWelcome to the online “book” for the Programming Module of the TiSEM Minor Essential Digital Skills. We will follow the content in this book during the lectures and it is the basis of the material that will appear on the exam, so you should read through this book carefully. Because this book is new, it is likely that we will make some edits throughout the course.\nBefore we jump into coding with Python, we will start by discussing what programming is at the most basic level and motivating why we are learning how to code in Python in the first place.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-a-programming-language",
    "href": "index.html#what-is-a-programming-language",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.2 What is a Programming Language?",
    "text": "1.2 What is a Programming Language?\nWithout getting into a complicated details, a programming language is a way to communicate to a computer via written text in a way that the computer can understand you so that you can instruct it to do various operations. This is very different to how we usually interact with a computer, which often involves pointing and clicking on different buttons and menus with your mouse.\nKnowing how to program is a very useful skill because you can automate repetitive tasks that would otherwise take you a very long time if you had to them “by hand” (i.e. by clicking things with your mouse). For example, suppose you work in a hotel in a city and you need to check how much your competitors are charging for rooms on different days so that you can adjust prices to stay competitive. Every day you have to go to all the different websites of the competing hotels and take note of the prices in an Excel sheet. With programming, what you could do instead is write code that tells the computer to automatically visit those websites every day, record the hotel room prices, and put them into a dataset for you. This is a process called web scraping and can be done with Python. This is just one example of the many ways programming languages can automate repetitive tasks.\nWhen humans speak to each other and someone makes a grammar mistake, it usually isn’t a big deal. We usually know what they mean. But if you make a “syntax error” in a programming language, it won’t understand what you mean. The computer will throw an error. What is worse still is a “semantic error” which is when the computer runs your code without an error but does something you didn’t want it to do. Therefore we need to be very careful when writing in a programming language.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#why-python",
    "href": "index.html#why-python",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.3 Why Python?",
    "text": "1.3 Why Python?\nThere are many different programming languages out there: C, C++, C#, Java, JavaScript, R, Julia, Stata, MATLAB, Fortran, Ruby, Perl, Rust, Go, Lua, Swift - the list goes on. So why should we learn Python over these other alternatives?\nThe best programming language depends on the task you want to accomplish. Are you building a website, writing computer software, creating a game, or analyzing data? While many languages could perform all of these tasks, some languages excel in some of them. In this course our goal is to learn basic programming techniques required for data science, and Python is by far the most popular programming language for this task. But it’s not only useful for that. It is also often used in web development, creating desktop applications and games, and for scientific computations. It is therefore a very versatile programming language that can complete a very wide range of tasks.\nPython is also completely free and open source and can run on all common operating systems. This means you can share your code with anyone and they will be able to run it, no matter what computer they are on or where they are in the world.\nThere is also a very large active community that creates packages to do a wide-range of operations, keeping Python up to date with the latest developments. For example, excellent community help is available at Stackoverflow, so if you Google how to do something in Python most likely that question has already been answered on Stackoverflow. Funnily enough, a key skill to develop with programming is how to formulate your question into Google to land on the right Stackoverflow page. More recently, ChatGPT and other generative artificial intelligence tools have become very useful resources for Python. These can write excellent Python code and also explain all the steps it takes, so I encourage you to use them to help you learn. However, keep in mind you will not be able to use AI in the exam, so don’t become too reliant on it!\nThese days employers are increasingly looking to hire people with programming skills. Knowing how to program in Python - one of the most commonly used languages by companies - is therefore a very valuable addition to your CV.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html",
    "href": "02-getting-started.html",
    "title": "2  Getting Started",
    "section": "",
    "text": "2.1 Installing Anaconda\nIn this chapter we will learn how to install Python and run our very first command.\nThe easiest way to install Python is by installing Anaconda. You can do this by visiting https://www.anaconda.com/download.\nYou should see this page:\nYou should click the “Skip registration” button (although feel free to register if you like). You will then see the following page:\nYou should then click on the “Download” button. Mac users will see a Mac logo instead.\nAfter downloading the file, click on it to install it. Follow the installation wizard and keep all the default options during installation.\nAfter installation you will see a number of new applications on your computer. These are:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#installing-anaconda",
    "href": "02-getting-started.html#installing-anaconda",
    "title": "2  Getting Started",
    "section": "",
    "text": "Anaconda Download Page\n\n\n\n\n\n\nAnaconda Download Page\n\n\n\n\n\n\nSpyder. This is a computer application that allows you to write Python scripts and execute them to see the output. Such an application is called an Integrated Desktop Environment (IDE). We will see how to use this below.\nJupyter Notebook. This is a web application that allows you to write a notebook (like a report) with text and Python code snippets with output. We will learn how to use this application later in this course.\nAnaconda Prompt. This is a way to manage and update packages from the command line. Packages are collections of modules that give Python more functionality, allowing you to perform different types of tasks more easily. All the packages that we will need for this course are installed by default when we install Anaconda, so we will not need to use this in this course.\nAnaconda Navigator. This is a graphical user interface for the Anaconda prompt. This essentially allows you to manage your packages without having to learn the different commands required by the Anaconda prompt. We won’t need to use this application in this course either.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#spyder",
    "href": "02-getting-started.html#spyder",
    "title": "2  Getting Started",
    "section": "2.2 Spyder",
    "text": "2.2 Spyder\nOpen the Spyder program installed by Anaconda. You should see an application that looks like this:\n\n\n\nSpyder\n\n\n\n2.2.1 Python Console\nIn the bottom right pane you see a console with IPython. IPython is short for Interactive Python. We can type Python commands into this console and see the output directly. To find 1+1 in Python, we can use the command 1+1, similar to how we would do it in Excel or in the Google search engine. Let’s try this out in the console. First, click on the console to move the cursor there. Then type 1+1 and press Enter. We will see the output 2 on the next line next to a red Out [1]:\n\n\n\nIPython Console\n\n\nThe red Out [1] means this is the output from the first line of input (after the green In [1]). The second command will have input In [2] and output Out [2].\n\n\n2.2.2 Python Scripts\nTyping commands directly into the IPython console is fine if all you want to do is try out a few different simple commands. However, when working on a project you will often be executing many commands. If you were to do all of this in the interactive console it would be very easy to lose track of what you are doing. It would also be very easy to make mistakes.\nWriting your commands in Python scripts is a solution to this problem. A Python script is a text file with a .py extension where you can write all of your commands in the order you want them run. You can then get Spyder to run the entire file of commands. You can also ask it to only run part of the file. This has many advantages over typing commands into the console:\n\nIf you have run 10 commands to calculate something and then afterwards you decide to change what happened in one of the earlier commands, you would often have type all the commands again. In a script you would just need to edit the line with that command. So scripts can save you a lot of time.\nYou or anyone else can easily reproduce your work by re-running the Python script.\nBy having all the commands in a script you can more easily spot any mistakes you might have.\nIt is a way of saving your work.\n\nTherefore it’s best practice to write your code in scripts. In the exam, you will also have to supply your script with your answers.\nIn Spyder, in the left pane you see a file open called temp.py. This is an example Python script. We can ignore what is written in the first 6 lines of the script. We can add our 1 + 1 command to the bottom of the script like this and save it:\n\n\n\nPython Script\n\n\nIn the Toolbar there are several ways to run this command from the script. For example, you can run the entire file, or run only the current line or selected area. If the cursor is on the line with 1 + 1 and we press the “Run selection or current line” button, then we will see the command and output appear in the IPython console, just like how we typed it there before. Using the script, however, we have saved and documented our work.\nIf you try run the entire file, you will see runfile('...') in the IPython console with the ... being the path to the Python script you are running. However, you don’t see a 2 in the output. This is because when running an entire file, Python does not show the output of each line being run. To see the output of any command we need to put it inside the print() function. We can change our line to print(1 + 1) to see the output when running the entire file:\n\n\n\nUsing the print() function\n\n\nWhen you run the entire file you should now see a 2 below the runfile('...') command.\nWe now know how to write and run Python scripts! In the next chapter we will learn more Python commands.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#code-snippets-in-this-book",
    "href": "02-getting-started.html#code-snippets-in-this-book",
    "title": "2  Getting Started",
    "section": "2.3 Code Snippets in This Book",
    "text": "2.3 Code Snippets in This Book\nIn this book, we won’t always show screenshots like we did above. Instead we will show code snippets in boxes like this:\n\n1 + 1\n\n2\n\n\nThe part that is code will be in color and there will be a small clipboard icon on the right which you can use to copy the code to paste into your script to be able to experiment with it yourself. The output from the code will always be in a separate gray box below it (without a clipboard icon).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html",
    "href": "03-python-as-a-calculator.html",
    "title": "3  Python as a Calculator",
    "section": "",
    "text": "3.1 Addition, Subtraction, Multiplication and Division\nIn this chapter we will learn how to use Python as a calculator. In Chapter 2 we already saw how to calculate 1 + 1. We will now go through some different operations. We will also learn about functions and their arguments along the way, which we will be be using again and again throughout the rest of this course.\nWe start with the most basic operations. Addition, subtraction, multiplication and division are given by the standard +, -, * and / operators that you would use in other programs like Excel. For example:\nAddition:\n2 + 3\n\n5\nSubtraction:\n5 - 3\n\n2\nMultiplication:\n2 * 3\n\n6\nDivision:\n3 / 2\n\n1.5\nIt is also possible to do multiple operations at the same time using parentheses. For example, suppose we wanted to calculate: \n\\frac{2+4}{4\\times 2} = \\frac{6}{8} = 0.75\n We can calculate this in Python as follows:\n(2 + 4) / (4 * 2)\n\n0.75",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#troubleshooting-escaping-in-python",
    "href": "03-python-as-a-calculator.html#troubleshooting-escaping-in-python",
    "title": "3  Python as a Calculator",
    "section": "3.2 Troubleshooting: “Escaping” in Python",
    "text": "3.2 Troubleshooting: “Escaping” in Python\nSuppose by accident you left out the closing parentheses above. You typed (2 + 4) / (4 * 2 and Enter. You don’t see the output but instead see\nIn [1]: (2 + 4) / (4 * 2\n   ...:\nPython did not run the command, but it also did not give an error. What happened is that because there was no closing parenthesis Enter moved to a new line instead of executing the command. That’s why we see the ...:. To “Escape” this situation, you just need to press the Ctrl+C button. In general, if anything strange happens in Python and you get stuck, you can always press Ctrl+C in the console to escape the current command.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#exponentiation-taking-powers-of-numbers",
    "href": "03-python-as-a-calculator.html#exponentiation-taking-powers-of-numbers",
    "title": "3  Python as a Calculator",
    "section": "3.3 Exponentiation (Taking Powers of Numbers)",
    "text": "3.3 Exponentiation (Taking Powers of Numbers)\nx^n multiplies x by itself n times. For example, 2^3=2\\times 2\\times 2 = 8. In Python we use ** to do this:\n\n2 ** 3\n\n8\n\n\nBe very careful not to use ^ for exponentiation. This actually does a very different thing that we won’t have any use for in this course.1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#absolute-value",
    "href": "03-python-as-a-calculator.html#absolute-value",
    "title": "3  Python as a Calculator",
    "section": "3.4 Absolute value",
    "text": "3.4 Absolute value\nTaking the absolute value turns a negative number into the same number without a minus sign. It has no effect on positive numbers.\nIn mathematical notation we write |x| for the absolute value of x. The formal definition is:\n\n|x| = \\begin{cases} x & \\text{ if } x \\geq 0 \\\\ -x & \\text{ otherwise}\n\\end{cases}\n\nHere are some examples:\n\n|-2|=2\n|3|=3.\n\nThis is what the function looks like when we plot it for different x:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-10, 10, 400)\n\n# Define the absolute value function\ny = np.abs(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = |x|')\n\n# Add labels and title\nplt.title('Absolute Value Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nWe’ll learn how to make plots like this later in this course, but if you want to see the code generating it you can click on the button “Show code generating the plot below”.\nIn Python we can calculate absolute values with:\n\nabs(-2)\n\n2\n\n\n\nabs(3)\n\n3\n\n\nTaking the absolute value in Python involves using what is called a function. Functions are used by calling their names and giving the arguments to the function in parentheses. When we do abs(-2), abs is the name of the function and -2 is the argument.\nIn many ways the functions in Python work a lot like the functions in Excel, just they might have different names or be used a bit differently. For example, in Excel you write =ABS(-2) to take the absolute value of -2. The argument is the same, and the function name only differs in that in Excel you need to use capital letters whereas in Python you use lowercase letters (in addition, Excel requires you to put an = before the function name).\nWhen using functions it is helpful to read their help pages. You can look at this by typing help(abs) in the Console and pressing Enter. We then see:\nHelp on built-in function abs in module builtins:\n\nabs(x, /)\n    Return the absolute value of the argument.\nThis tells us that abs() takes a single argument and returns the absolute value.2\nWe will be using many different functions and it’s a good habit of to look at their help pages. The help pages will be available to you in the Exam.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#square-roots",
    "href": "03-python-as-a-calculator.html#square-roots",
    "title": "3  Python as a Calculator",
    "section": "3.5 Square Roots",
    "text": "3.5 Square Roots\nThe square root of a number x is the y that solves y^2=x. For example, if x=4, both y=-2 and y=2 solve this. The principal square root is the positive y from this.\nHere is what the square root function looks like for different x:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range (positive values because np.sqrt() not defined for negative\n# values)\nx = np.linspace(0, 10, 400)\n\n# Define the square root function\ny = np.sqrt(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = √x')\n\n# Add labels and title\nplt.title('Square Root Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nThe principal square root a number is equal to the number exponentiated by \\frac{1}{2}:\n\n\\sqrt{x} = x^\\frac{1}{2}\n\n\n9 ** (0.5)\n\n3.0\n\n\nWe can follow a very similar approach to above to get the cubed root of a number, such as: \\sqrt[3]{8}=8^\\frac{1}{3}=2:\nIn Python:\n\n8 ** (1/3)\n\n2.0\n\n\nPython also has a square root function, but it is not built in. We need to load this function by loading the module math. A module is a collection of additional functions and other objects that we can load in our Python script. The module math contains many mathematical functions, including the sqrt() function.\nTo load the math module, we need to include import math in our script before executing any of its functions. To run the sqrt() function from the math module, we need to type math.sqrt(). This “dot” notation means we use the sqrt() function within the math module.\nTo get \\sqrt{9} then we can do:\n\nimport math\nmath.sqrt(9)\n\n3.0\n\n\nTo view the help page math.sqrt(), we can use help(math.sqrt).\nIf you only want to use the sqrt() function from the math module, you could alternatively import the function the following way:\n\nfrom math import sqrt\nsqrt(9)\n\n3.0\n\n\nThis way you don’t need to type math.sqrt() every time you want to take the square root, and only need to type sqrt(). However, it is generally preferred practice to import the math module using import math and use the function with math.sqrt(). This makes the code clearer and easier to understand.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#exponentials",
    "href": "03-python-as-a-calculator.html#exponentials",
    "title": "3  Python as a Calculator",
    "section": "3.6 Exponentials",
    "text": "3.6 Exponentials\nA very important function in mathematics and statistics is the exponential function. The definition of \\exp\\left(x\\right), or e^x, is given by: \ne^x = \\underset{n\\rightarrow \\infty}{\\lim} \\left(1 + \\frac{x}{n}\\right)^n\n\nNote: you don’t need to know or remember this definition for the exam. You only need to know how to calculate the exponential function in Python.\nThis is what the function looks like:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-2, 2, 400)\n\n# Define the exponential function\ny = np.exp(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = e^x')\n\n# Add labels and title\nplt.title('Exponential Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nIn Python we can use the exp() function from the math module to calculate the exponential of any number:\n\nmath.exp(1)\n\n2.718281828459045",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#logarithms",
    "href": "03-python-as-a-calculator.html#logarithms",
    "title": "3  Python as a Calculator",
    "section": "3.7 Logarithms",
    "text": "3.7 Logarithms\nAnother common mathematical function is the logarithm, which is like the reverse of exponentiation.\nThe log of a number x to a base b, denoted \\log_b\\left(x\\right), is the number of times we need to multiply b by itself to get x. For example, \\log_{10}\\left(100\\right) = 2, because 10\\times 10=100. We need to multiply the base b=10 by itself twice to get to x=100.\nA special logarithm is the natural logarithm, \\log_e(x), which is the logarithm to the base \\exp(1)=e^1\\approx 2.7183. This is also written as \\ln(x).\nThis is what the function looks like:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range (positive values only, since ln(x) is undefined for non-positive x)\nx = np.linspace(0.1, 10, 400)  # Start from 0.1 to avoid log(0), which is undefined\n\n# Define the natural logarithm function\ny = np.log(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\n\nplt.plot(x, y, label='y = ln(x)')\n\n# Add labels and title\nplt.title('Natural Logarithm Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nIn Python we use the log() function from the math module to calculate the natural logarithm:\n\nimport math\nmath.log(1)\n\n0.0\n\n\nWhat if we want to calculate the logarithm to a base other than e? If we look at the help page for log() using help(math.log), we see:\nHelp on built-in function log in module math:\n\nlog(...)\n    log(x, [base=math.e])\n    Return the logarithm of x to the given base.\n    \n    If the base not specified, returns the natural logarithm (base e) of x.\nWe can see that the log() function can take 2 arguments:\n\nx: the number we want to take the log of.\nbase: the base with respect to which the logarithms are computed. The default is math.e which equals the value of e\\approx 2.718. Because this argument is contained in a square bracket, it means it is an optional argument. If we don’t provide it, it will use the default.\n\nThis is the first time that we have seen a function with more than one argument. Earlier when we used the math.log() to calculate the natural logarithm we only used one argument because we used the default setting for the base. But when we want to use a base other than e, we need to specify it.\nCalculate \\log_{10}\\left(100\\right) in Python is then done as follows:\n\nimport math\nmath.log(100, 10)\n\n2.0\n\n\nWe write both arguments into the math.log() function, separated by commas.\nThe math module contains many more mathematical functions. To see all the functions available in the math module, we can use the command dir(math). You will see many familiar mathematical functions, such as the trigonometric functions sin(), cos(), and tan().",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#integer-division-and-the-modulus-operator",
    "href": "03-python-as-a-calculator.html#integer-division-and-the-modulus-operator",
    "title": "3  Python as a Calculator",
    "section": "3.8 Integer Division and The Modulus Operator",
    "text": "3.8 Integer Division and The Modulus Operator\nWhen we divide 7 by 3 we get 2\\frac{1}{3}. We could alternatively say that “7 divided by 3 equals 2 with remainder 1”. When programming it is often useful to get these numbers. The tutorial exercises will have several examples of this!\nWe can perform “integer division” with the // operator. This always returns the fraction rounded down to the nearest whole number:\n\n7 // 3\n\n2\n\n\nTo get the remainder we use the modulus operator %:\n\n7 % 3\n\n1\n\n\nTogether then 7/3 is 2 with remainder 1.\nOne thing to note is that integer division with negative numbers doesn’t round to the integer closest to zero, but always down. So:\n\n-7 // 3\n\n-3\n\n\nand:\n\n7 // -3\n\n-3\n\n\nboth give -3 and not -2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#footnotes",
    "href": "03-python-as-a-calculator.html#footnotes",
    "title": "3  Python as a Calculator",
    "section": "",
    "text": "For example, 2^3 converts 2 and 3 to binary (10 and 11 respectively) and then does a “bitwise exclusive OR operation” (XOR) on these. Because the first bits both the same (both 1), XOR is a 0 and because the second two bits are different (0 and 1), XOR is a 1. Together this is 01, which is a 1 when converted back to an integer. So 2 ** 3 gives 8 but 2^3 gives 1.↩︎\nThe forward slash in abs(x, /) marks the end of the positional-only arguments in the function. The abs() function takes only one argument, so you can think of this slash as meaning there is only one argument to abs(). Some functions like the math.log() function that we will see below have two arguments (the number we are taking the log of and the base) and the position (order) of the arguments we provide matter. Other functions, such as the print() function we have already encountered, allow you to provide arguments by a keyword (see help(print) for these).↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html",
    "href": "04-data-types-part1.html",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "4.1 Variables\nIn this chapter we will learn about variables and data types for single values. In Chapter 5 we will learn about data types that can contain multiple values.\nIn Python we can assign single values to variables and then work with and manipulate those variables.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#variables",
    "href": "04-data-types-part1.html#variables",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "4.1.1 Assigning Values to Variables\nAssigning a single value to a variable is very straightforward. We put the name we want to give to the variable on the left, then use the = symbol as the assignment operator, and put the value to the right of the =. The = operator binds a value (on the right-hand size of =) to a name (on the left-hand side of =).\nTo see this at work, let’s set x=2 and y=3 and calculate x+y:\n\nx = 2\ny = 3\nx + y\n\n5\n\n\nIn Spyder there is a “Variable Explorer” in the top-right pane to see the variables we have created:\n\n\n\nVariable Explorer in Spyder\n\n\nWe can see that x has a value 2 and y has a value 3.\nWhen we assign x=2, in our code, the value is not fixed forever. We can assign a new value to x. For example, we can assign the number 6 to x instead:\n\nx = 6\nx + y\n\n9\n\n\nFinally, you cannot set x=2 with the command 2 = x. That will result in an error. The name must be on the left of = and the value must be on the right of =.\n\n\n4.1.2 Rules for Naming Variables\nVariable names can be multiple letters long and can contain underscores (_). Underscores are useful because variable names cannot contain spaces and so we can use underscores to represent spaces. Variable names can contain numbers but they cannot start with one. For example x1 and x_1 are legal names in Python, but 1x is not. There are 35 keywords that are reserved and cannot be used as variable names because they are fundamental to the language. For example, we cannot assign a value to the name True, because that is a keyword. Below is the list of all keywords.1 We will learn what many of these keywords are later in this course and how to use them.\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#common-data-types-for-single-values",
    "href": "04-data-types-part1.html#common-data-types-for-single-values",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.2 Common Data Types for Single Values",
    "text": "4.2 Common Data Types for Single Values\n\n4.2.1 Integers\nYou may have noticed that the “Variable Explorer” in Spyder had a “Type” column. For x and y this was int which means “integer”. Integers are whole numbers that can also be negative. We can also check the type of a variable using the type() function:\n\ntype(x)\n\nint\n\n\n\n\n4.2.2 Floating-Point Numbers\nNumbers that are not whole numbers have the type float, which stands for floating-point number:\n\ntype(1.2345)\n\nfloat\n\n\nAll the operations we learned about in Chapter 3 also work with floating-point numbers. For example:\n\n1.2 * 3\n\n3.5999999999999996\n\n\nYou will notice that we don’t get 3.6 like we expected, but instead something very very close but slightly different to 3.6. This is because of how floating-point numbers are represented internally by the computer. The number is split into an integer with a fixed degree of precision and an exponential scaler. For example 1.2 is the same as 12\\times 10e^{-1}, so the computer needs two integers: 12 and -1 (the exponent) to represent 1.2. Because this process involves some approximations when we perform arithmetic operations on them we can lose some accuracy. However, for most purposes 3.5999999999999996 is close enough to 3.6.\n\n\n4.2.3 Strings\nPython can also work with text in the form of strings. Text in Python needs to be wrapped in quotes. These can be either single quotes (') or double quotes (\"), provided they match.\n\ntype('Hello world')\n\nstr\n\n\n\ntype(\"This is a string\")\n\nstr\n\n\nThis str means it is a “string” which is a sequence of individual characters.\nOne thing to be careful with strings is that if you have a string that contains double quotes you have to wrap it in single quotes and vice versa:\n\nquote = 'Descartes said \"I think, therefore I am\" in 1637'\napostrophe = \"Don't wrap this with single quotes!\"\n\nIf you find yourself in the unusual situation with a string with both single and double quotes, you can wrap them in triple single quotes ('''):\n\nquote_with_apostrophe = '''As they say, \"Don't judge a book by its cover\"'''\n\nAnother thing to be careful with strings is that numbers surrounded by quotes are strings and not numbers:\n\ntype('1.2')\n\nstr\n\n\nWe can use some of the operators for numbers on strings, but they do very different things. The + operator combines strings:\n\na = 'Hello, '\nb = 'world'\na + b\n\n'Hello, world'\n\n\nAnd the * operator repeats strings:\n\na = 'Hello! '\na * 3\n\n'Hello! Hello! Hello! '\n\n\n\n\n4.2.4 Boolean Values\nIn programming it is often useful to work with variables that are either true or false. Therefore Python has a special data type for this called the Boolean data type. This is named after George Boole who was a mathematics professor in Ireland in the 1800s.\nThe Boolean values are either True or False. The words must be capitalized and spelled exactly this way. These are two of Python’s keywords.\n\na = True\nb = False\ntype(a)\n\nbool\n\n\nTrue and False are 2 of the keywords that cannot assign values to. Try 2 = True yourself and see the error that you get.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#logical-and-comparison-operators",
    "href": "04-data-types-part1.html#logical-and-comparison-operators",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.3 Logical and Comparison Operators",
    "text": "4.3 Logical and Comparison Operators\n\n4.3.1 Logical Operators\nBoolean values have their own operations: and, or and not. These are called logical operators. These work as follows:\n\na and b is True if both a and b are True. Otherwise it is False (if either or both of a or b are False). Here are all the possible combinations:\n\n\n\n\na\nb\na and b\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nFalse\nFalse\nFalse\n\n\n\n\na or b is True if either a or b (or both) are True. Otherwise it is False (if both a and b are False). Here are all the possible combinations:\n\n\n\n\na\nb\na or b\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\n\n\n\n\nnot a is True if a is False and is False if a is True. The not operator flips the value. Here are all the possible combinations:\n\n\n\n\na\nnot a\n\n\n\n\nTrue\nFalse\n\n\nFalse\nTrue\n\n\n\nLet’s try them out on two specific values a and b, where a is True and b is False:\n\na = True\nb = False\na and b\n\nFalse\n\n\nThis is False because we need both a and b to be True.\n\na or b\n\nTrue\n\n\nThis is True because at least one of a or b is True.\n\nnot a\n\nFalse\n\n\nThis is False because a is True. It flips the value.\n\n\n4.3.2 Comparison Operators\nPython has operators to check if one number is equal to, not equal to, greater than (or equal to), or less than (or equal to) another number. It checks the (in)equality and returns True or False depending on the result.\nTo check if a=b, we use the == operator:\n\na = 3\nb = 2\na == b\n\nFalse\n\n\na\\neq b, so we get False. Be careful to use two equal symbols and not one. If we did a = b, it would just reassign to a the value of b (2):\n\na = 3\nb = 2\na = b\na\n\n2\n\n\nTo check if a\\neq b, we use the != operator (which is supposed to look like the \\neq symbol):\n\na = 3\nb = 2\na != b\n\nTrue\n\n\nThis is True, because a and b are not equal.\nTo see if a&gt;b, we use &gt; and to see if a\\geq b we use a &gt;= b:\n\na = 3\nb = 2\na &gt;= b\n\nTrue\n\n\nWe get True because a\\geq b.\nTo see if a&lt;b, we use &lt; and to see if a\\leq b we use a &lt;= b:\n\na = 3\nb = 2\na &lt;= b\n\nFalse\n\n\nWe get False because a\\ngeq b.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#type-conversion",
    "href": "04-data-types-part1.html#type-conversion",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.4 Type Conversion",
    "text": "4.4 Type Conversion\nWe can sometimes convert objects between int, float, str and bool. Sometimes this conversion is not so intuitive so you need to be careful and know how it works.\nIf we assign x=1, it will automatically be made an int:\n\nx = 1\ntype(x)\n\nint\n\n\nBut we can convert x to a float using the float() function. Let’s assign y to be x as a float:\n\ny = float(x)\ntype(y)\n\nfloat\n\n\n\ny\n\n1.0\n\n\nWe can see that y is not 1 but 1.0. The .0 helps us recognize that this is a float.\nWe can also convert the integer to a string:\n\nz = str(x)\ntype(z)\n\nstr\n\n\n\nz\n\n'1'\n\n\nThe quotes around the 1 helps us recognize that this is a string.\nFinally we can also convert from a float to a string:\n\nstr(y)\n\n'1.0'\n\n\nIf you have an integer stored as a string, we can convert it back to an integer:\n\nint('1')\n\n1\n\n\nOr you can convert it to a float:\n\nfloat('1')\n\n1.0\n\n\nAnd if a float is stored as a string, we can convert it back to a float:\n\nfloat('1.5')\n\n1.5\n\n\nHowever, it is not possible to convert '1.5' to an integer - that will return an error. Similarly you cannot convert strings with characters to integers or floats.\nWe can also convert floats to integers:\n\nint(1.0)\n\n1\n\n\nIf we try to convert a float that isn’t a whole number to an integer it will always take the closest integer to zero. For positive numbers this means it always rounds down:\n\nint(1.1)\n\n1\n\n\n\nint(1.9)\n\n1\n\n\nAnd for negative numbers it always rounds up:\n\nint(-2.1)\n\n-2\n\n\n\nint(-2.9)\n\n-2\n\n\nThe Boolean values True and False can be converted to integers, floats and strings. True becomes 1, 1.0 and 'True' and False becomes 0, 0.0 and 'False', respectively. We can also convert integers 1 and 0 back to Boolean:\n\nbool(1)\n\nTrue\n\n\n\nbool(0)\n\nFalse\n\n\nHowever, if we try convert strings to Boolean we get some unintuitive results. For example:\n\nbool('0')\n\nTrue\n\n\n\nbool('False')\n\nTrue\n\n\nNon-empty strings always return True. Only empty strings return False:\n\nbool('')\n\nFalse\n\n\nThis is an example of when a programming language does something unintuitive. Therefore when writing a longer program you really need to be sure what each line is doing, otherwise your program will do something unexpected.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#footnotes",
    "href": "04-data-types-part1.html#footnotes",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "The keyword module contains functions for testing if a string is a keyword. The command keyword.kwlist returns the full list of keywords.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html",
    "href": "05-data-types-part2.html",
    "title": "5  Data Types for Multiple Values",
    "section": "",
    "text": "5.1 Introduction\nIn Chapter 4 we learned about the int, float, str and bool data types, which all had single values. But we often have to deal with many values. For example, suppose you wanted to analyze the past daily sales of a company in recent years. It would not be very convenient to assign each of the hundreds of values of sales to different variables and work with them. Python has other data types available to deal with multiple values: lists, tuples, dictionaries, sets and frozen sets. These will be the focus of this chapter.\nIn later chapters we will also see that there are Python modules that have other data types. In this chapter we will focus on the data types that come built in.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#lists",
    "href": "05-data-types-part2.html#lists",
    "title": "5  Data Types for Multiple Values",
    "section": "5.2 Lists",
    "text": "5.2 Lists\nA very common way to store a sequence of values (which could be integers, floats, strings or Booleans), is in a list. You can create a list by putting the values in between square brackets, separated by commas:\n\na = [2, 4, 6]\na\n\n[2, 4, 6]\n\n\nLists can also be composed of floats, Booleans, or strings, or even a combination of them:\n\na = [1, 1.1, True, 'hello']\n\nLists can even have other lists as elements:\n\na = [1, 2, [3, 4]]\n\nAlthough we see 4 numbers, this list actually has only 3 elements:\n\nlen(a)\n\n3\n\n\nwhere the len() function returns the length of its argument. The [3, 4] is actually considered one element and is itself a list. This kind of a list is called a nested list.\n\n5.2.1 List Operations\nIf we use the + operator on lists it just creates a longer list with one appended to the other:\n\na = [2, 4, 6]\nb = [8, 10]\na + b\n\n[2, 4, 6, 8, 10]\n\n\nIf we use the * operator it repeats the list:\n\na = [2, 4, 6]\na * 3 \n\n[2, 4, 6, 2, 4, 6, 2, 4, 6]\n\n\nWe cannot use the - and / operators on lists. In these ways lists behave like strings.\n\n\n5.2.2 List Indexing\nLists are ordered so the order in which we place the elements matters. To extract a particular value from a list based on its position in the list we can use a method called indexing. If we want the first element of the list we can extract it with a[0]:\n\na[0]\n\n2\n\n\nThe 0 here is the index. It means to take element 0 from the list. In Python and several other programming languages (like C and C++), counting starts at 0 instead of 1. So element 0 is actually the 1st element. This is something that might take some getting used to, so be careful when using indexing.\nEven though the list has 3 elements, the last element is extracted with a[2]:\n\na[2]\n\n6\n\n\nIf you try to do a[3] you get an IndexError saying the list index is out of range.\nWe can also use negative indexing to extract elements from the end of a list. For example, to get the last element of a list a we can use a[-1], to get the second-last element we can use a[-2], and so on:\n\na = [1, 2, 3, 4, 5, 6]\na[-1]\n\n6\n\n\n\na[-2]\n\n5\n\n\nIndexing like this also works for strings, and many other objects with multiple values. For example, to get the first character in a string we can get the value at index 0:\n\na = 'hello'\na[0]\n\n'h'\n\n\nWe can also use indexing to change values in a list:\n\na = [2, 4, 6]\na[0] = 8\na\n\n[8, 4, 6]\n\n\nBecause lists have this property, we say they are mutable. This is unlike strings which are immutable. You can’t change a character in a string using indexing (try it out with the commands a = 'hello' and a[0] = g).\n\n\n5.2.3 List Slicing\nTo get all elements starting from 1 up to but not including index 3 (the 2nd and 3rd element) we can do:\n\na = [1, 2, 3, 4, 5]\na[1:3]\n\n[2, 3]\n\n\nTo get all elements starting from index 2 (the 3rd element onwards) we can do:\n\na[2:]\n\n[3, 4, 5]\n\n\nTo get all elements up to but not including index 2 (the 1st and 2nd element) we can do:\n\na[:2]\n\n[1, 2]\n\n\nFinally, the following just returns the original list:\n\na[:]\n\n[1, 2, 3, 4, 5]\n\n\n\n\n5.2.4 List Methods\nLists, like many objects in Python, have methods. A method in Python is like a function but instead of using the object as an argument to the function, we apply the function to the object. We’ll see what we mean by this with an example. Suppose we wanted to add another number to our list at the end, like the number 8. Instead of recreating the entire list with a = [2, 4, 6, 8], we can append 8 to the end of the list using the append() method. Methods are invoked by placing them after the object separated with a . like this:\n\na = [2, 4, 6]\na.append(8)\na\n\n[2, 4, 6, 8]\n\n\nNotice that we didn’t need to assign the output of append() to an object with =. It altered a in place. This is what the method does.\nTo remove an element from a list we can use the pop() method. For example, to remove the 2nd element (element with index 1), we can do:\n\na = [2, 4, 6]\na.pop(1)\na\n\n[2, 6]\n\n\nAnother list method is reverse() which reverses the ordering of the list:\n\na = [2, 6, 4]\na.reverse()\na\n\n[4, 6, 2]\n\n\nTo sort a list ascending we can use sort():\n\na = [1, 3, 2]\na.sort()\na\n\n[1, 2, 3]\n\n\nTo see the full list of methods available for your list, you can use the command dir(a).\nUsing the sort() method changes our original list. Sometimes we want to see the sorted version of a list but then go back to the original ordering. In this case you shouldn’t use the sort() method on the list but use the sorted() function to create a sorted version of the list. The sorted() function returns its input sorted:\n\na = [1, 3, 2]\nb = sorted(a)\nb\n\n[1, 2, 3]\n\n\n\n\n5.2.5 Iterating over Items in a List\nA useful feature of a list is that we can iterate over each element, performing the same operation or set of operations on each element one by one. For example, suppose we wanted to see what the square of each element in the list was. We can use what is called a for loop to do this. Here is how to code it:\n\na = [2, 4, 6, 8]\nfor i in a:\n    print(i ** 2)\n\n4\n16\n36\n64\n\n\nIn words, what is happening is “for all i in the list a, print i^2”. We use i as a sort of temporary variable for each element in a. The next line then prints i ** 2 which squares i. You will notice that the print() command is indented with 4 spaces. This is to tell Python that this command is part of the loop. When there is code under the for loop that is not indented, Python interprets this as not being part of the loop.\nTo understand this, compare the following two snippets, which are almost the same except the first print('hello') is indented and the second is not:\n\na = [2, 4, 6, 8]\nfor i in a:\n    print(i ** 2)\n    print('hello')\n\n4\nhello\n16\nhello\n36\nhello\n64\nhello\n\n\n\na = [2, 4, 6]\nfor i in a:\n    print(i ** 2)\nprint('hello')\n\n4\n16\n36\nhello\n\n\nThe first code prints 'hello' 3 times, and the second only once, even though the code looks almost the same except for the indentations. This is because in the first case, the indentation tells Python that the second print() call is part of the loop. In each iteration of the loop, we have to print the square of i and print hello. The loop iterates 3 times, so we see 'hello' 3 times.\nIn the second case, the lack of indentation tells Python that the print('hello') is not in the loop. Python first finishes the loop (squaring each element of a and printing it). It only then gets to the next part of the code and prints 'hello'.\nTherefore it is very important to be careful with indentation with Python. You should indent with 4 spaces (and not a tab) for content in a loop.\nAnother thing to note here is that a for loop is a situation where the code is no longer running line-by-line from top to bottom. The code goes to the end of the loop and if there are iterations remaining to be done it goes back to the start of the loop. Only when it has completed all the iterations does it go to the next line after the loop.\n\n\n5.2.6 List Comprehensions\nSuppose we wanted to save the square of each element of a into a new list called b. One way to do that would be to create an empty list called b with b = []. This is a list with no elements. Then we could use the for loop to append the values to b, like this:\n\na = [2, 4, 6]\nb = []\nfor i in a:\n  b.append(i ** 2)\nb\n\n[4, 16, 36]\n\n\nThis works just fine, but the code is a bit “clunky”. Moreover, if your list is very very large it would run very slowly. A cleaner and faster way to do this kind of operation is by using list comprehensions.\n\na = [2, 4, 6]\nb = [i ** 2 for i in a]\nb\n\n[4, 16, 36]\n\n\nThis is a very neat and compact way to create the new list. It also reads similar to how we would describe what is happening: “make a list which is i^2 for all elements i in the list a”.\n\n\n5.2.7 List Membership\nTo see if an element is contained somewhere in a list, we can use the in operator:\n\na = [2, 4, 6]\n4 in a\n\nTrue\n\n\n\n5 in a\n\nFalse\n\n\n4 is in a so we get True, but 5 is not so we get False.\n\n\n5.2.8 Copying Lists\nOne thing to note about lists, which may be unexpected, is that if we create a list a and set b = a, we are actually telling Python that a and b refer to the same object, not just that they have the same values. This has the consequence that if we change a that b will also change. For example:\n\na = [2, 4, 6]\nb = a\na[0] = 8\nb\n\n[8, 4, 6]\n\n\nWe set b = a but otherwise perform no operations on b. We change the first element of a (element 0) to 8, and the first element of b changes to 8 as well!\nOften when we are programming we don’t want this to happen. We often want to copy a list to a new one to perform some operations and leave the original list unchanged. What we can do instead is set b equal to a[:] instead of a. This way b won’t change when a changes:\n\na = [2, 4, 6]\nb = a[:]\na[0] = 8\nb\n\n[2, 4, 6]\n\n\nAnother way is to use the copy() method:\n\na = [2, 4, 6]\nb = a.copy()\na[0] = 8\nb\n\n[2, 4, 6]\n\n\nBecause there are two different ways of copying objects with different consequences, we have two different terms for them:\n\nDeep copy: This copies a to b and recursively copies all of its elements, resulting in a completely independent object.\nShallow copy: This copies a to b but does not recursively copy its elements. Instead it only copies the references to the elements in a (like the address for where in the computer’s memory those elements are stored). This means that changes to elements of a will affect the elements of b.\n\nThe b = a example is a shallow copy and the b = a[:] example is like a deep copy. However, it is not a full deep copy. Using a[:] or a.copy() only works if our list is not nested. This method only takes a deep copy of the outermost list. If we copy with a[:] or a.copy() to b with a nested listed and then change an element inside one of the nested lists, then the copied object will change as well. For example:\n\na = [2, 4, [6, 8]]\nb = a[:]\na[2][1] = 5\nb\n\n[2, 4, [6, 5]]\n\n\nb changes as well! The same happens with the copy() method:\n\na = [2, 4, [6, 8]]\nb = a.copy()\na[2][1] = 5\nb\n\n[2, 4, [6, 5]]\n\n\nTo make a full deep copy which recursively copies the entire object, we can use the deepcopy() function from the copy module:\n\nimport copy\na = [2, 4, [6, 8]]\nb = copy.deepcopy(a)\na[2][1] = 5\nb\n\n[2, 4, [6, 8]]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#tuples",
    "href": "05-data-types-part2.html#tuples",
    "title": "5  Data Types for Multiple Values",
    "section": "5.3 Tuples",
    "text": "5.3 Tuples\nA tuple is another data type that is quite similar to a list. One important difference, however, is that they are immutable. We cannot change individual values of a tuple after they are created, and we cannot append values to a tuple.\nWe can create a tuple in Python using parentheses instead of square brackets:\n\na = (2, 4, 6)\n\nIndexing and many other operations that work for lists also work with tuples. We index them the same way as lists (using square brackets like a[0]) and we can iterate over the items with for loops in the same way. However the list of methods for tuples is much shorter. We cannot append or pop values because the tuples are immutable.\n\n5.3.1 Tuple Assignment\nOne useful thing we can do with tuples is tuple assignment. Suppose we have a list x = ['a', 'b', 'c'] and we wanted to create 3 objects from this: x_0 = 'a', x_1 = 'b' and x_2 = 'c'. One way to do this is:\n\nx = ['a', 'b', 'c']\nx_0 = x[0]\nx_1 = x[1]\nx_2 = x[2]\n\nBut a much more elegant way to do this is using tuple assignment:\n\nx = ['a', 'b', 'c']\n(x_0, x_1, x_2) = x\n\nThis assigns 'a' to x_0, 'b' to x_1 and 'c' to x_2 all in one line.\nThis is especially useful if you have a function that returns multiple objects and we want to assign each output to a different variable. For example, the function divmod(a, b) gives the quotient and remainder from dividing a with b. It essentially calculates a // b and a % b and returns a tuple with both objects:\n\ndivmod(7, 3)\n\n(2, 1)\n\n\nThis means 7 divided by 3 is 2 with remainder 1. We can use tuple assignment with the output to get:\n\n(quotient, remainder) = divmod(7, 3)\nquotient\n\n2\n\n\n\nremainder\n\n1",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#dictionaries",
    "href": "05-data-types-part2.html#dictionaries",
    "title": "5  Data Types for Multiple Values",
    "section": "5.4 Dictionaries",
    "text": "5.4 Dictionaries\nAnother common built-in data type is a dictionary. A dictionary maps keys to values, where the keys can be an immutable data type (usually an integer or string) and the values can be any type, for example, single values, lists, or tuples. For example, a company might have supplier IDs for its suppliers and a dictionary mapping those IDs to the actual company name. In this case, the company IDs are the keys and the company names are the values.\nWe could create a simple dictionary like this as follows:\n\nsuppliers = {100001 : 'ABC Ltd.', 100002 : 'EFG Ltd.'}\n\nDictionaries are created within curly brackets with the structure {key1 : value1, key2 : value2, key3 : value3}.\nTo find a company name using the company ID we provide the key in the place we would supply an index for a list or tuple:\n\nsuppliers[100001]\n\n'ABC Ltd.'\n\n\nDictionaries are unordered, so we cannot do suppliers[0] to find the first supplier. There is no first value in a dictionary.\nWe can also add new keys and values to the dictionary:\n\nsuppliers[100003] = 'HIJ Ltd.'\nsuppliers\n\n{100001: 'ABC Ltd.', 100002: 'EFG Ltd.', 100003: 'HIJ Ltd.'}\n\n\nWe can also modify values:\n\nsuppliers[100003] = 'KLM Ltd.'\nsuppliers\n\n{100001: 'ABC Ltd.', 100002: 'EFG Ltd.', 100003: 'KLM Ltd.'}\n\n\nTo get all the keys in a dictionary we can use the keys() method:\n\nsuppliers.keys()\n\ndict_keys([100001, 100002, 100003])\n\n\nAnd to get all the values in a dictionary we can use the values() method:\n\nsuppliers.values()\n\ndict_values(['ABC Ltd.', 'EFG Ltd.', 'KLM Ltd.'])\n\n\nUsing a for loop with a dictionary implicitly iterates over the keys. So we can loop over the keys of a dictionary in the following way:\n\nfor key in suppliers:\n    print('Supplier with ID ' + str(key) + ' is ' + suppliers[key])\n\nSupplier with ID 100001 is ABC Ltd.\nSupplier with ID 100002 is EFG Ltd.\nSupplier with ID 100003 is KLM Ltd.\n\n\nFinally, to create an empty dictionary we can use {}.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#sets-and-frozen-sets",
    "href": "05-data-types-part2.html#sets-and-frozen-sets",
    "title": "5  Data Types for Multiple Values",
    "section": "5.5 Sets and Frozen Sets",
    "text": "5.5 Sets and Frozen Sets\nA set is another way to store multiple items into a single variable. Sets are unordered and unindexed. This means you cannot extract individual elements using their index like a list, nor by their key like a dictionary.\nYou can create a set by placing items (like integers or strings) inside curly brackets ({}) separated by commas:\n\nmyset = {'apple', 'banana', 'cherry'}\nmyset\n\n{'apple', 'banana', 'cherry'}\n\n\nSets cannot have duplicate items. It only keeps the unique values. For example, suppose we provide 'cherry' twice:\n\nmyset = {'apple', 'banana', 'cherry', 'cherry'}\nmyset\n\n{'apple', 'banana', 'cherry'}\n\n\nIt only keeps the first 'cherry'.\nYou are, however, able to add and remove elements to a set.\n\nmyset = {'apple', 'banana', 'cherry'}\nmyset.add('pear')\nmyset\n\n{'apple', 'banana', 'cherry', 'pear'}\n\n\n\nmyset = {'apple', 'banana', 'cherry'}\nmyset.remove('apple')\nmyset\n\n{'banana', 'cherry'}\n\n\nConverting a list to a set is useful if you want to get the list of unique elements:\n\nfruits = ['apple', 'apple', 'apple', 'banana', 'cherry', 'banana']\nset(fruits)\n\n{'apple', 'banana', 'cherry'}\n\n\nWe can iterate over sets just like lists (with for i in myset). We can also perform set operations on pairs of sets.\nFor example, for two sets A and B, we can find A\\cap B (the set of elements contained in both sets) using:\n\nset_a = {1, 2, 4, 6, 8, 9}\nset_b = {2, 3, 5, 7, 8}\nset_a.intersection(set_b)\n\n{2, 8}\n\n\nThe numbers 2 and 8 are the only numbers in both sets.\nTo find A\\cup B (the set of elements contained in either set) we can do:\n\nset_a.union(set_b)\n\n{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nThis gets all the numbers appearing in the two sets (dropping duplicates).\nTo find A\\setminus B (the set of elements in A not contained in B) we can do:\n\nset_a.difference(set_b)\n\n{1, 4, 6, 9}\n\n\n1, 4, 6 and 9 are in A and not in B. The number 2, for example, is not here because that is also in B.\nTo create a set that is immutable (so that you cannot add or remove items), you can use the frozenset() function:\n\nmyset = frozenset([1, 2, 3])\n\nYou can still use the same operations on frozensets as normal sets, except you cannot modify them once they are created.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html",
    "href": "06-defining-functions.html",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "",
    "text": "6.1 Introduction\nWe have used a number of Python functions so far, such as the absolute value function and the square root function. In this chapter we will learn how we can create our own functions. We will also learn how to use conditional statements inside functions.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#structure-of-a-function",
    "href": "06-defining-functions.html#structure-of-a-function",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.2 Structure of a Function",
    "text": "6.2 Structure of a Function\nWe will start off learning how to program a very basic function. Consider the function that returns its input plus one. Mathematically the function would be represented as:\n\nf(x)=x+1\n So f(0)=1, f(1)=2 and f(2)=3 and so on. In Python we can create this function with:\n\ndef add_one(x):\n    y = x + 1\n    return y\n\nThe def tells Python we are creating a function. We then provide the functions name (here add_one). After that we put in the function’s arguments in parentheses, separated by commas. Here there is only one argument so we just write x. Then like with a for loop we add a : and add the body of the function below it indented by 4 spaces. Here the only thing the function does is create y which is x + 1. We then get the function to return the output, which is y.\nLet’s try it out:\n\nadd_one(2)\n\n3\n\n\nWe get the expected output!\nOne thing to note about this function is that the y that is assigned x + 1 in the function is never stored in our environment. The y only exists within the function and is deleted after the function ends. We cannot access it outside. We say that y is a local variable (it is local to the function). It is possible to define global variables within a function that can be accessed after the function is called, but for our purposes doing so is generally not very good practice and so we will not cover that here.\nWe could also shorten our code by doing the calculation on the same line as the return command:\n\ndef add_one(x):\n    return x + 1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#commenting-in-python",
    "href": "06-defining-functions.html#commenting-in-python",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.3 Commenting in Python",
    "text": "6.3 Commenting in Python\nAs we start to write longer programs that include functions, it’s s good idea to start annotating your code to help other people understand its purpose (and also you when you look back at your own code after a couple of days!). We can do this by adding comments. In Python we can add a comment by using the # character. Everything after the # character is ignored by the Python interpreter, so what we write after it don’t need to be “legal” Python commands. We can add a comment to describe what a function does like this:\n\n# This function returns the input plus one:\ndef add_one(x):\n    return x + 1\n\nWe can also add comments to the same line as code we want to run provided we put it after the command. Like this:\n\n2 ** 3  # this command calculates 2 to the power of 3\n\n8",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#conditional-execution",
    "href": "06-defining-functions.html#conditional-execution",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.4 Conditional Execution",
    "text": "6.4 Conditional Execution\n\n6.4.1 If-Else Statements\nConditional statements, or “if-else statements”, are very useful and extremely common in programming. In an if-else statement, the code first checks a particular true/false condition. If the condition is true, it performs one action, and if the condition is false, it performs another action.\nA simple example of this is the absolute value function we saw in Chapter 3. Let’s define precisely what that function does:\n\n|x| = \\begin{cases}\n-x & \\text{ if } x &lt; 0 \\\\\nx & \\text{ otherwise}\n\\end{cases}\n\nIf x&lt;0 it returns -x, so that the negative number turns positive. Otherwise (if x=0 or it is positive), it keeps the value of x the same.\nAlthough Python already has an absolute value function (abs()), let’s create our own function (called my_abs()) that does the same thing. To do this we use conditional statements (if and else). Here’s how it works:\n\ndef my_abs(x):\n    if x &lt; 0:\n        y = -x\n    else:\n        y = x\n    return y\n\nThe function first checks if x&lt;0. If it is true, it performs the operation under if (sets y=-x) and skips past the else statement and returns y. If it is false (i.e. x \\not &lt; 0) then it skips past the operation under the if statement and instead does the operation under the else statement (sets y=x) before returning y.\nLet’s try it out using some different values:\n\n[my_abs(i) for i in [-2, 0, 3]]\n\n[2, 0, 3]\n\n\nJust like with the add_one() function above we can shorten this function definition. We could alternatively do:\n\ndef my_abs(x):\n    if x &lt; 0:\n        return -x\n    else:\n        return x\n\nThe function first checks if x&lt;0. If it is true, it returns -x and ends. It doesn’t go any further. If x \\not &lt; 0 then it skips the operation under if and does the operation under else (returns x).\nThis gives the same output:\n\n[my_abs(i) for i in [-2, 0, 3]]\n\n[2, 0, 3]\n\n\nThis means the return part of a function doesn’t have to be at the end of a function. But you should be aware that once a function returns a value it does not continue executing the remaining statements.\nFor example, consider the following code:\n\ndef bad_add_one(x):\n    return x\n    y = x + 1\n    return y\n[bad_add_one(i) for i in [1, 2, 3]]\n\n[1, 2, 3]\n\n\nThis is very similar to the first add_one() function we defined above. The only difference is that we write return x as the first command in the function’s body. Although the code sets y=x+1 and returns y, the output is always the same as the input. This is because the function returns x at the top, which means the rest of the function is never executed.\n\n\n6.4.2 If-Else If-Else Statements\nSometimes we want to do one thing if a certain condition holds, another thing if a different condition holds, and something else in the remaining cases. An example of this is the “sign” function, which tells you the sign in front of a value:\n\nsgn(x) = \\begin{cases}\n-1 & \\text{ if } x &lt; 0 \\\\\n0 & \\text{ if } x = 0 \\\\\n+1 & \\text{ otherwise} \\\\\n\\end{cases}\n If the value is negative, we get -1. If it’s zero we get 0. If it’s positive (the remaining case), we get +1.\nTo do this in Python, we could nest several if-else statements:\n\ndef sign(x):\n    if x &lt; 0:\n        return -1\n    else:\n        if x == 0:\n            return 0\n        else:\n            return 1\n[sign(i) for i in [-2, 0, 3]]\n\n[-1, 0, 1]\n\n\nThe function does the following:\n\nIf x&lt;0, return -1.\nOtherwise proceed to the next if-else:\n\nIf x=0, return 0.\nOtherwise (if x&gt;0), return 0.\n\n\nAlthough this works, this is quite complicated and difficult to follow. Some of the return statements are indented 4 times, for what should be such a simple function. For these kinds of situations we can make use of the elif statement. Here is an alternative way to make this function using elif:\n\ndef sign(x):\n    if x &lt; 0:\n        return -1\n    elif x == 0:\n        return 0\n    else:\n        return 1\n[sign(i) for i in [-2, 0, 3]]\n\n[-1, 0, 1]\n\n\nIn words, what the code does in this case is:\n\nIf the 1st check is true (x&lt;0), the function returns -1 and it done.\nIf the 1st check is false (x\\not &lt;0), the function checks x=0. If that is true it returns 0 and it done.\nIf the 1st and 2nd checks are false (x\\not &lt;0 and x\\neq 0), the function returns 1 and it done.\n\nIt actually does exactly the same as the first code, but because there is less nesting it is easier to follow and is preferred (especially when you have even more conditions to check!).\n\n\n6.4.3 While Loops\nA while loop is another very common method in programming. A while loop repeats a set of commands whenever a certain condition is true. A while loop also makes it possible to run an infinite loop. To have the sequence of numbers 1, 2, 3, \\dots printed on your screen forever (or until you kill the program) you could do:\nx = 0\nwhile True:\n    x += 1\n    print(x)\nNote: the x += 1 here is a shorter way of writing x = x + 1. The operations -=, *= and /= also work like this - try them out!\nBecause True will always be True, the loop will just keep running forever, adding 1 each time. Eventually the numbers will get so big that x will show up as inf (infinity), but you would have to let the program run for a very long time before you saw that.\nA while loop is also useful if you want to repeat a loop until something happens, but you don’t know how many times you need to run it before that happens. One instance when this would occur is if you wanted to numerically approximate a mathematical equation with an iterative algorithm. You want to repeat the iterations until the output starts to stabilize to a certain tolerance (accuracy) level, but you don’t know in advance how many iterations this will take. Let’s take a look at an example of this now.\nThe example we will look at is the way the ancient Greeks approximated square roots. Suppose you wanted to find the square root of x. What the ancient Greeks did is start with an initial guess of this y_0, let’s say \\frac{x}{2}. You then find the updated guess y_1 according to the formula:1 \ny_1 = \\frac{1}{2} \\left( y_0 + \\frac{x}{y_0}\\right)\n When you have y_1 we can update this for a more accurate approximation with: \ny_2 = \\frac{1}{2} \\left( y_1 + \\frac{x}{y_1}\\right)\n To write this in general terms, given an initial guess y_0, we update y_n, with n=1,2,\\dots according to: \ny_n = \\frac{1}{2} \\left( y_{n-1} + \\frac{x}{y_{n-1}}\\right)\n\nYou continue updating this way until y_n stops changing very much (for example it changes by less than 0.000001 in an iteration).\nLet’s work manually with this algorithm to see how well it works. Suppose we want the square root of 2 which we know is approximately equal to 1.414214. Let’s start with a guess y_0=\\frac{x}{2}=\\frac{2}{2}=1. This is quite far off the true 1.414214 but we’ll go with it anyway. We can update the guess with the formula:\n\ny_1 = \\frac{1}{2}\\left(y_0 + \\frac{x}{y_0}\\right) =\n\\frac{1}{2}\\left(1 + \\frac{2}{1}\\right) =1.5\n This is already a lot closer (0.0858 away). Let’s do the next approximation step:\n\ny_2 = \\frac{1}{2}\\left(y_1 + \\frac{x}{y_1}\\right) =\n\\frac{1}{2}\\left(1.5 + \\frac{2}{1.5}\\right) = 1.416667\n This is already pretty close (0.00245 away)! Let’s do one more:\n\ny_3 = \\frac{1}{2}\\left(y_2 + \\frac{x}{y_2}\\right) =\n\\frac{1}{2}\\left(1.416667 + \\frac{2}{1.416667}\\right) = 1.414216\n It’s now only 0.0000021 away from the precise answer! That might be close enough for most purposes, and we can always do another iteration to improve its accuracy.\nLet’s see how to code this in Python:\n\ndef my_sqrt(x, tol=0.000001):\n    # Arguments:\n    #  x   : number to take the square root of.\n    #  tol : tolerance level of algorithm.\n  \n    # Set initial guess:\n    y = x / 2\n  \n    # Initialize distance:\n    dist = tol + 1 \n    \n    # Update guesses until y changes by less than tol:\n    while dist &gt; tol:\n        # Previous guess:\n        y_old = y\n        # Update guess:\n        y = (y_old + x / y_old) / 2\n        # Calculate distance from last guess:\n        dist = abs(y - y_old)\n    return y\n\nWe have written a function that can take 2 arguments: x, the number we want to take the square root of, and tol, which is the tolerance level for how accurate our approximation should be (a lower number is more accurate). When we write tol=0.000001 in the function definition it means we say that 0.000001 is the default value for tol. If we don’t provide the argument it will use this value, but we can specify a different value if we want.\nWe now talk about the code in the function. The function first sets y_0=\\frac{x}{2} as the initial guess. It also needs to set dist = tol + 1 because the while loop checks if dist &gt; tol. For this check, dist needs to exist locally in the function (tol is created from the arguments). And for the while loop to run at least once the dist needs to start at a value bigger than tol. This is why we add one. Inside the while loop then, because we want to compare how our guess changes, we set y_old = y before setting the new y according to the approximation formula. Then we get the absolute value of the difference between the new and old guess. We then go back to the top of the loop and we check if dist is still bigger than tol. If it is, it repeats the steps again. If not, the while loop terminates and we go to the next stage, where y is returned as the output.\nLet’s try it out. First using the default value:\n\nmy_sqrt(2)\n\n1.414213562373095\n\n\nWe get an approximation that is very close to math.sqrt(2):\n\nimport math\nmath.sqrt(2)\n\n1.4142135623730951\n\n\nCan we specify a looser tolerance as follows:\n\nmy_sqrt(2, 0.1)\n\n1.4166666666666665\n\n\nAs expected, this is less accurate.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#footnotes",
    "href": "06-defining-functions.html#footnotes",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "",
    "text": "To understand where this formula comes from, start with the equation we are trying to solve: y^2=x. Dividing this across by 2y gives \\frac{y}{2}=\\frac{x}{2y}. Then adding \\frac{y}{2} to both sides gives y=\\frac{y}{2}+\\frac{x}{2y}. If we use y=\\sqrt{x} this equation will hold exactly. But because this is what we are trying to find out, we start with a guess of y (in our case \\frac{x}{2}). We use this guess for y on the right hand side together with x to find an updated guess for y on the left hand side.↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html",
    "href": "07-intro-to-numpy.html",
    "title": "7  Introduction to NumPy",
    "section": "",
    "text": "7.1 Introduction\nPython’s built-in data types like lists and tuples are not particularly well-suited for mathematical operations. We will show three examples of computations that we often need to do, and we will see that using lists involves quite a lot of coding to get the tasks done. We will then see that NumPy can do these tasks very efficiently.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#three-example-problems",
    "href": "07-intro-to-numpy.html#three-example-problems",
    "title": "7  Introduction to NumPy",
    "section": "7.2 Three Example Problems",
    "text": "7.2 Three Example Problems\n\nExample 1\nFor the first example, suppose we have a list x of numbers and we want to double each of the elements. We can’t use 2 * x because as we learned in Chapter 5 that just repeats the list twice. We have to do something like:\n\nx = [2, 4, 8]\ny = []\nfor i in x:\n    y.append(2 * i)\ny\n\n[4, 8, 16]\n\n\nWe create an empty list y. We then loop over the elements of x and append two times the element to y. This is very clunky. A better way of doing this is using a list comprehension:\n\nx = [2, 4, 8]\n[2 * i for i in x]\n\n[4, 8, 16]\n\n\nBut this is still a bit clunky. We would prefer a method that can just do 2 * x and get the same output.\n\n\nExample 2\nAnother example computation that we often need to do is if we have two lists of numbers x and y with the same number of elements and and we want to multiply them by each other element-by-element. Expressed in mathematical notation, suppose we have two vectors of numbers \\boldsymbol{x} and \\boldsymbol{y}: \n\\begin{split}\n\\boldsymbol{x}&=\\left[x_1, x_2, \\dots, x_n\\right] \\\\\n\\boldsymbol{y}&=\\left[y_1, y_2, \\dots, y_n\\right] \\\\\n\\end{split}\n and we want to calculate \\boldsymbol{z} from this which is:\n\\boldsymbol{z}=\\left[x_1 \\times y_2, x_2 \\times y_2, \\dots, x_n \\times y_n\\right]\n We can’t do x * y. That would return an error. But we could do this using a for loop:\n\nx = [2, 4, 8]\ny = [3, 2, 2]\nz = []\nfor i in range(len(x)):\n    z.append(x[i] * y[i])\nz\n\n[6, 8, 16]\n\n\nBecause we want to loop over the elements of both x and y, we have to loop over the indices 0, 1, 2. We could have written for i in [0, 1, 2], but range(len(x)) does this for us automatically (which is very useful if we have a long list). To see better what range is doing we can do:\n\nlist(range(5))\n\n[0, 1, 2, 3, 4]\n\n\nWe can see it creates a list from 0 up to but not including the argument.\nWe can improve on this code slightly by using the zip() function, which combines several iterables into one iterable.\n\nx = [2, 4, 8]\ny = [3, 2, 2]\nz = []\nfor i, j in zip(x, y):\n    z.append(i * j)\nz\n\n[6, 8, 16]\n\n\nSimilarly we can use zip() to do the task with a list comprehension:\n\nx = [2, 4, 8]\ny = [3, 2, 2]\n[i * j for i, j in zip(x, y)]\n\n[6, 8, 16]\n\n\nEven though we have now shortened the command down to one line, this last solution is still pretty clunky and also quite complicated. We would prefer an operation where we can just do x * y.\n\n\nExample 3\nFor the last example, suppose we want to find the median of a list of numbers. Recall that if the length of the list of numbers is odd, then the median is just the number in the middle when we sort the numbers. If the length of the list of numbers is even, then the median is the average of the two numbers closest to the middle when we sort the numbers.\nWe could create our own function to do this:\n\ndef median(x):\n    y = sorted(x)\n    if len(y) % 2 == 0:\n        return (y[len(y) // 2 - 1] + y[len(y) // 2]) / 2\n    else:\n        return y[len(y) // 2]\n\nThe function first sorts the list. The sorted() function gives the sorted list as the output. We do this instead of x.sort() because otherwise the function would sort our input list globally which we may not want it to do. The if len(y) % 2 == 0: checks if the length of the list is even. If it is even it takes the average of the element with index len(y) // 2 - 1 (just left of the middle) and the element with index len(y) // 2 (just right of the middle). We use // to ensure the division returns an integer instead of a float. If the length of the list is odd it returns the element with index len(y) // 2. Because len(y) / 2 is not an integer when len(y) is odd we use // to round down.\nLet’s test it out:\n\nmedian([2, 6, 4])\n\n4\n\n\n\nmedian([2, 6, 4, 3])\n\n3.5\n\n\nWe get the expected ouptut. However, this is quite complicated. We wouldn’t want to have to code this function every time we wanted to do something as common as finding the median.\nWe will see that functions from the module numpy can solve each of these problems (and a lot more) very easily.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#importing-the-numpy-module",
    "href": "07-intro-to-numpy.html#importing-the-numpy-module",
    "title": "7  Introduction to NumPy",
    "section": "7.3 Importing the NumPy Module",
    "text": "7.3 Importing the NumPy Module\nWe can import the numpy module using import numpy like with other modules. However it is conventional to load NumPy the following way:\n\nimport numpy as np\n\nThis way we can use the functions from NumPy with the shorter np instead of having to type numpy out in full every time. Doing this shortcut is okay because so many people do it that it’s easy for people to read. You can load other modules with shortcuts in a similar way, but you should follow the normal conventions when you can.\nNumPy works with arrays. An array is like a list but all elements must be of the same type (such as all floats). We can create an array using NumPy’s array function. Because we can shorten numpy to np, we can create an array with the function np.array() like this:\n\nimport numpy as np\nx = np.array([2, 4, 8])\nx\n\narray([2, 4, 8])\n\n\nWe will now show the power of NumPy by doing all the previous examples with very little code.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#solving-the-example-problems-with-numpy",
    "href": "07-intro-to-numpy.html#solving-the-example-problems-with-numpy",
    "title": "7  Introduction to NumPy",
    "section": "7.4 Solving the Example Problems with NumPy",
    "text": "7.4 Solving the Example Problems with NumPy\n\nExample 1\nTo double every number in array:\n\nx = np.array([2, 4, 8])\n2 * x\n\narray([ 4,  8, 16])\n\n\n\n\nExample 2\nTo multiply the elements of two arrays element-by-element:\n\nx = np.array([2, 4, 8])\ny = np.array([3, 2, 2])\nx * y\n\narray([ 6,  8, 16])\n\n\n\n\nExample 3\nTo get the median of an array:\n\nx = np.array([2, 6, 4])\nnp.median(x)\n\nnp.float64(4.0)\n\n\n\nx = [2, 6, 4, 3]\nnp.median(x)\n\nnp.float64(3.5)\n\n\nThe np.median() function also works if we just provide a list instead of an np.array:\n\nnp.median([2, 6, 4, 3])\n\nnp.float64(3.5)\n\n\nThese are just a few examples of how NumPy can simplify coding drastically.\nFor many programming tasks we need to do, it’s very often many people had to do the same thing before. This means there is often a module available that can do the task. Of course we learn a lot from coding functions from scratch, but in order to complete a task quickly and efficiently it is usually better to use the modules made for the task.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#matrix-operations",
    "href": "07-intro-to-numpy.html#matrix-operations",
    "title": "7  Introduction to NumPy",
    "section": "7.5 Matrix Operations",
    "text": "7.5 Matrix Operations\nNumPy can also do matrix operations very easily. For example, suppose we had two 3 \\times 3 matrices \\boldsymbol{A} and \\boldsymbol{B}:\n\n\\boldsymbol{A}\n= \\left(\\begin{matrix}\n     1 & 2 & 3 \\\\\n     2 & 3 & 1 \\\\\n     3 & 1 & 3\n  \\end{matrix}\\right)\n\\qquad\n\\boldsymbol{B}\n= \\left(\\begin{matrix}\n    2 & 1 & 2 \\\\\n    3 & 2 & 1 \\\\\n    1 & 3 & 1 \\\\\n\\end{matrix}\\right)\n and wanted to calculate their product \\boldsymbol{C}=\\boldsymbol{AB}.\nManually, we could calculate each row i and column j of \\boldsymbol{C} with \\sum_{k=1}^3 a_{ik} b_{kj}. For example, row 2 and column 1 of \\boldsymbol{C} would be: \n\\begin{split}\nc_{21}&=\\sum_{k=1}^3 a_{2k} b_{k1}\\\\&=\na_{21} b_{11} +\na_{22} b_{22} +\na_{23} b_{33}\\\\\n&=\n2\\times2 + 3 \\times 3 + 1 \\times 1\\\\&=4+9+1\\\\&=14\n\\end{split}\n But doing this for all 9 elements would take a long time, and we could easily make a mistake along the way. Let’s use Python to calculate it instead.\nIf we were to try and do this with only built-in Python commands, it would still be rather complicated. We could define the matrices \\boldsymbol{A} and \\boldsymbol{B} using nested lists, where each list contains 3 lists representing the rows:\n\nA = [\n    [1, 2, 3],\n    [2, 3, 1],\n    [3, 1, 3]\n]\n\nB = [\n    [2, 1, 2],\n    [3, 2, 1],\n    [1, 3, 1]\n]\n\nTo calculate \\boldsymbol{C}=\\boldsymbol{AB} then we follow the same approach as the manual way. We loop through each row i and each column j of the matrix and calculate: c_{ij} = \\sum_{k=1}^3 a_{ik} b_{kj}. We do this by starting with a zero matrix and progressively fill it up.\n\nC = [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n]\n\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            C[i][j] += A[i][k] * B[k][j]\n\nfor row in C:\n    print(row)\n\n[11, 14, 7]\n[14, 11, 8]\n[12, 14, 10]\n\n\nThis is an example of a triple-nested loop: a loop inside a loop inside a loop.\nUsing NumPy to do the multiplication is much easier. We can just use the np.dot() function:\n\nimport numpy as np\nA = np.array(A)\nB = np.array(B)\nnp.dot(A, B)\n\narray([[11, 14,  7],\n       [14, 11,  8],\n       [12, 14, 10]])\n\n\nNumPy can also do many other matrix operations, such as:\n\ntransposing with the command np.transpose()\ninversion with the command np.linalg.inv().\n\nYou can therefore use Python to help you with the Mathematics course that you are taking alongside this one!",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "08-files-and-pandas.html",
    "href": "08-files-and-pandas.html",
    "title": "8  Data handling with Pandas",
    "section": "",
    "text": "8.1 Data frames\nIn this chapter, we will go over some of the basics of importing, adjusting and exporting data in Python. For the adjusting part, we will rely on the Pandas package, which is a data analysis package. We start by explaining how to use Pandas data frames, a convenient way to store large datasets. Afterwards, we will explain how you can import data from a file into a data frame, and how to export it to another file.\nThe Pandas package pandas is typically imported under the alias pd.\nWe will start with a small data set consisting of six persons and some personal information about these people. The data is given in the following dictionary. It contains the names, height, weight, age and dietary preference (i.e., dictionary keys) of everyone.\ndataset = {\n 'name' : [\"Aiden\", \"Bella\", \"Carlos\", \"Dalia\", \"Elena\", \"Farhan\"],\n 'height (cm)' : [185, 155, 190, 185, 160, 170],\n 'weight (kg)' : [80, 60, 100, 85, 62, 75],\n 'age (years)' : [23, 23, 23, 21, 19, 25],\n 'dietary preference' : ['Veggie','Veggie','None','None','Vegan','None']\n}\n\nprint(dataset.keys())\n\ndict_keys(['name', 'height (cm)', 'weight (kg)', 'age (years)', 'dietary preference'])\nA dictionary is not a convenient datatype to perform data analysis on. Therefore, we load the data into a so-called data frame using the DataFrame() function from pandas.\ndf = pd.DataFrame(dataset)\n\nprint(df)\n\n     name  height (cm)  weight (kg)  age (years) dietary preference\n0   Aiden          185           80           23             Veggie\n1   Bella          155           60           23             Veggie\n2  Carlos          190          100           23               None\n3   Dalia          185           85           21               None\n4   Elena          160           62           19              Vegan\n5  Farhan          170           75           25               None\nAs you can see here, the keys of the dictionary become the column names of the data frame, and the values are stored in the corresponding column. You can also see the index of the row at the far left. Here we call the data frame df (short for data frame), but you can name it whatever you like.\nBecause we have a relatively small data set, the complete data frame is printed. If the data contains a large number of rows, typically the first and last five rows are printed in the console of Spyder. A data frame is an object of the type DataFrame with which you can do all kinds of things.\nprint(type(df))\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data handling with Pandas</span>"
    ]
  },
  {
    "objectID": "08-files-and-pandas.html#data-frames",
    "href": "08-files-and-pandas.html#data-frames",
    "title": "8  Data handling with Pandas",
    "section": "",
    "text": "8.1.1 Accessing\nIf you want to print the first or last k rows, you can use the functions df.head(k) and df.tail(k), respectively, with df being the name of your data frame.\n\n# Print first three rows of df\nprint(df.head(3))\n\n     name  height (cm)  weight (kg)  age (years) dietary preference\n0   Aiden          185           80           23             Veggie\n1   Bella          155           60           23             Veggie\n2  Carlos          190          100           23               None\n\n\n\n# Print last two rows of df\nprint(df.tail(2))\n\n     name  height (cm)  weight (kg)  age (years) dietary preference\n4   Elena          160           62           19              Vegan\n5  Farhan          170           75           25               None\n\n\nIt is also possible to access specific rows or elements from the data frame using indexing.\nTo extract row i, use df.loc[i].\n\n# Extract row 0 (i.e., info of Aiden)\nx = df.loc[0]\n\nprint(x)\n\nname                   Aiden\nheight (cm)              185\nweight (kg)               80\nage (years)               23\ndietary preference    Veggie\nName: 0, dtype: object\n\n\nTo extract a specific column, use df.loc[:,'column_name'].\n\n# Extract age column\nx = df.loc[:,'age (years)']\n\nprint(x)\n\n0    23\n1    23\n2    23\n3    21\n4    19\n5    25\nName: age (years), dtype: int64\n\n\nAn alternative that not uses the loc[] function is df[column_name].\n\n# Extract age column\nx = df['age (years)']\n\nprint(x)\n\n0    23\n1    23\n2    23\n3    21\n4    19\n5    25\nName: age (years), dtype: int64\n\n\nIf a column name doesn’t contain spaces or special characters (apart from ’_’) then it’s also possible to extract a column using df.column_name. Let’s try this with the name column:\n\n# Extract name column\nx = df.name\n\nprint(x)\n\n0     Aiden\n1     Bella\n2    Carlos\n3     Dalia\n4     Elena\n5    Farhan\nName: name, dtype: object\n\n\nTo extract the entry from row i in column ‘column_name’ we use df.loc[i,column_name].\n\n# Extract the name and height from the person on row 0:\nx = df.loc[0,'name']\ny = df.loc[0,'height (cm)']\n\nprint(\"The height of\", x, \"is\", y, \"cm.\")\n\nThe height of Aiden is 185 cm.\n\n\nWe can also use slicing to return a specified range of rows. For example, rows i through j can be obtained using df.loc[i:j].\n\n# Extract first three rows\nx = df.loc[0:2]\n\nprint(x)\n\n     name  height (cm)  weight (kg)  age (years) dietary preference\n0   Aiden          185           80           23             Veggie\n1   Bella          155           60           23             Veggie\n2  Carlos          190          100           23               None\n\n\nThis works differently compared to slicing with lists. Recall there that if we want the first 3 elements of a list x then when we need to use x[0:3]. This is because the last element of the specified range (3 in this case) is not included when using slicing in lists:\n\n# Slicing in list\ny = [13,4,5,2,11]\n\n# Print first, second and third element of y:\nprint(y[0:3])\n\n[13, 4, 5]\n\n\nUsing slicing, we can also access specific combinations of columns and rows. Suppose we are only interested in the name, height and age of the first, second and third person in the frame. Because the columns have names (i.e., are not numbers), we index them by a list containing the column names that we are interested in.\n\n# Extract block with the first 3 rows and columns name, height and age:\nx = df.loc[0:2,['name','height (cm)', 'age (years)']]\n\nprint(x)\n\n     name  height (cm)  age (years)\n0   Aiden          185           23\n1   Bella          155           23\n2  Carlos          190           23\n\n\nIt is also possible to return a subset of rows that do not form a consecutive block. You can do this with a Boolean vector indicating for every row whether you want it to be included or not. For example, if we want to return only rows 0, 1, 4 and 5, we can do the following:\n\nrows = [True,True,False,False,True,True]\nx = df[rows]\n\nprint(x)\n\n     name  height (cm)  weight (kg)  age (years) dietary preference\n0   Aiden          185           80           23             Veggie\n1   Bella          155           60           23             Veggie\n4   Elena          160           62           19              Vegan\n5  Farhan          170           75           25               None\n\n\nHere rows is a Boolean list containing entries True and False with an element being True if and only if we want the row to be included (namely 0,1,4 and 5), and False otherwise (namely 2 and 3). We can achieve the same result with df.loc[[0,1,4,5]], i.e, by giving a list of the row entries that we are interested in.\nThe Boolean list approach is convenient, because it can also be used to select rows that satisfy a specified criterion. For example, suppose that we want to only select the rows of persons whose dietary preference is ‘None’. This can be achieved as follows.\n\n# Boolean vector no_pref indicating whether dietary preference is 'None'\nno_pref = df['dietary preference'] == 'None'\nprint(no_pref)\n\n0    False\n1    False\n2     True\n3     True\n4    False\n5     True\nName: dietary preference, dtype: bool\n\n\n\n# Extract rows for which list no_pref has 'True' entry\nx = df[no_pref]\n\nprint(x)\n\n     name  height (cm)  weight (kg)  age (years) dietary preference\n2  Carlos          190          100           23               None\n3   Dalia          185           85           21               None\n5  Farhan          170           75           25               None\n\n\nThe expression df['Dietary preference'] == 'None' checks for every row in the dietary preference column df['Dietary preference'] whether its entry is 'None'. If so, it returns True, and otherwise False. We store these True/False values in the list no_pref (short for having no dietary preference). We then use this Boolean list to extract the rows of the data frame consisting of the persons whose dietary preference is None.\nTo extract all the rows where no_pref is False we can do:\n\nx = df[~no_pref]\n\nprint(x)\n\n    name  height (cm)  weight (kg)  age (years) dietary preference\n0  Aiden          185           80           23             Veggie\n1  Bella          155           60           23             Veggie\n4  Elena          160           62           19              Vegan\n\n\nFor another example, let’s get all the rows for people who are at least 23 years old:\n\nx = df[df['age (years)'] &gt;= 23]\n\nprint(x)\n\n     name  height (cm)  weight (kg)  age (years) dietary preference\n0   Aiden          185           80           23             Veggie\n1   Bella          155           60           23             Veggie\n2  Carlos          190          100           23               None\n5  Farhan          170           75           25               None\n\n\nYou can also combine conditions with the logical & operator, provided each individual condition is in parentheses:\n\nx = df[(df['age (years)'] &gt;= 23) & (df['dietary preference'] == 'Veggie')]\n\nprint(x)\n\n    name  height (cm)  weight (kg)  age (years) dietary preference\n0  Aiden          185           80           23             Veggie\n1  Bella          155           60           23             Veggie\n\n\nTo do an OR condition, we use |. To get all rows with people 23 and over OR with vegetarian preferences.\n\nx = df[(df['age (years)'] &gt;= 23) | (df['dietary preference'] == 'Veggie')]\n\nprint(x)\n\n     name  height (cm)  weight (kg)  age (years) dietary preference\n0   Aiden          185           80           23             Veggie\n1   Bella          155           60           23             Veggie\n2  Carlos          190          100           23               None\n5  Farhan          170           75           25               None\n\n\n\n\n8.1.2 Editing\nIt is also possible to edit the data frame, both the data in the frame, as well as the column and row names. For example, it might be that we start with data that is not given in a dictionary, but rather in a matrix (which is a list of lists, where each of the inner lists forms a row of the matrix).\n\ndata = [\n[2,4,-1,2],\n[5,1,2,9],\n[3,7,8,9]\n]\n\ndf = pd.DataFrame(data)\n\nprint(df)\n\n   0  1  2  3\n0  2  4 -1  2\n1  5  1  2  9\n2  3  7  8  9\n\n\nNote that in this case both the rows and columns have their index number as name, so 0,1 and 2 for the rows and 0, 1, 2 and 3 for the columns. The names of the rows are stored in df.index and the columns in df.columns.\n\n# Row names are stored in df.index\nprint(df.index)\n\nRangeIndex(start=0, stop=3, step=1)\n\n\n\n# Rename rows\ndf.index = ['Row0','Row1','Row2']\n\n# Access the row names\nprint(df.index)\n\nIndex(['Row0', 'Row1', 'Row2'], dtype='object')\n\n\nIf you want to access specific column names, you can use indexing.\n\n# Print name of first column\nprint(df.index[1])\n\nRow1\n\n\nHere is the complete frame with row names adjusted.\n\n# Print data frame\nprint(df)\n\n      0  1  2  3\nRow0  2  4 -1  2\nRow1  5  1  2  9\nRow2  3  7  8  9\n\n\nNext, let us adjust the column names.\n\ndf.columns = ['Col0','Col1','Col2','Col3']\n\nprint(df)\n\n      Col0  Col1  Col2  Col3\nRow0     2     4    -1     2\nRow1     5     1     2     9\nRow2     3     7     8     9\n\n\nIt is also possible to alter the entries within the frame.\n\n# Edit entry on row 1, column 2\ndf.loc['Row1','Col2'] = 10\n\nprint(df)\n\n      Col0  Col1  Col2  Col3\nRow0     2     4    -1     2\nRow1     5     1    10     9\nRow2     3     7     8     9\n\n\nYou can also edit a complete row (or column)\n\n# Replace row 2\ndf.loc['Row2',:] = [-2,-2,-2,-2]\n\nprint(df)\n\n      Col0  Col1  Col2  Col3\nRow0     2     4    -1     2\nRow1     5     1    10     9\nRow2    -2    -2    -2    -2\n\n\n\n# Replace column 2\ndf.loc[:,'Col2'] = [-1,-1,-1]\n\nprint(df)\n\n      Col0  Col1  Col2  Col3\nRow0     2     4    -1     2\nRow1     5     1    -1     9\nRow2    -2    -2    -1    -2\n\n\nIt is also possible to edit the entries of an entire column by applying a function to it using apply(). For example, suppose that we want to square all the numbers in the second column. We can do this as follows.\n\ndef f(x):\n    return x**2\n\n# df['Col1'].apply(f) does not overwrite the entries in Col1\n# so we have to do this ourselves\ndf['Col1'] = df['Col1'].apply(f)\n\nprint(df)\n\n      Col0  Col1  Col2  Col3\nRow0     2    16    -1     2\nRow1     5     1    -1     9\nRow2    -2     4    -1    -2\n\n\nYou can also define and apply simple functions in one go using what are called lambda functions. Let’s square all the entries in Col1 again but this time using a lambda function:\n\ndf['Col1'] = df['Col1'].apply(lambda x: x**2)\nprint(df)\n\n      Col0  Col1  Col2  Col3\nRow0     2   256    -1     2\nRow1     5     1    -1     9\nRow2    -2    16    -1    -2\n\n\n\n\n8.1.3 Adding data\nIt is also possible to add entire new rows and columns.\n\ndata = [\n[2,4,-1,2],\n[5,1,2,9],\n[3,7,8,9]\n]\n\n# Create frame out of data\ndf = pd.DataFrame(data)\n\n# Name rows and columns\ndf.columns = ['Col0','Col1','Col2','Col3']\ndf.index = ['Row0','Row1','Row2']\n\nprint(df)\n\n      Col0  Col1  Col2  Col3\nRow0     2     4    -1     2\nRow1     5     1     2     9\nRow2     3     7     8     9\n\n\nNext, we add a row to the data frame. The loc[] command uses for this adds the row at the bottom of the current data frame.\n\n# Add a row\ndf.loc['New row'] = [5,5,3,1]\n\nprint(df)\n\n         Col0  Col1  Col2  Col3\nRow0        2     4    -1     2\nRow1        5     1     2     9\nRow2        3     7     8     9\nNew row     5     5     3     1\n\n\nThe same holds for adding a column, which is done as follows. Note that here we use [:,'New column'] and not ['New column'], because the latter would add the new data as a row.\n\ndf.loc[:,'New column'] = [1,1,1,1]\n\nprint(df)\n\n         Col0  Col1  Col2  Col3  New column\nRow0        2     4    -1     2           1\nRow1        5     1     2     9           1\nRow2        3     7     8     9           1\nNew row     5     5     3     1           1\n\n\nIt’s also possible to add a new column without using the loc[] command:\n\ndf['New column'] = [1,1,1,1]\n\nprint(df)\n\n         Col0  Col1  Col2  Col3  New column\nRow0        2     4    -1     2           1\nRow1        5     1     2     9           1\nRow2        3     7     8     9           1\nNew row     5     5     3     1           1\n\n\nYou can also add a new column with the insert() function. This allows you to specify at which position you want the column to be inserted. The insert() function needs three arguments: a position i where the column should be inserted, the column name and the column data, so the syntax is something like insert(i,column_name,column_data).\n\n# Insert column with name 'New column' at position 2.\ndf.insert(2,'Inserted column', [10,10,10,10])\n\nprint(df)\n\n         Col0  Col1  Inserted column  Col2  Col3  New column\nRow0        2     4               10    -1     2           1\nRow1        5     1               10     2     9           1\nRow2        3     7               10     8     9           1\nNew row     5     5               10     3     1           1\n\n\nAdding a row at a specific position is also possible, but this is more involved and omitted here.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data handling with Pandas</span>"
    ]
  },
  {
    "objectID": "08-files-and-pandas.html#mathematical-operations",
    "href": "08-files-and-pandas.html#mathematical-operations",
    "title": "8  Data handling with Pandas",
    "section": "8.2 Mathematical operations",
    "text": "8.2 Mathematical operations\nIt is also possible to obtain statistical information from numerical columns.\n\ndata = [\n[2,4,-1,2,'hello'],\n[5,1,2,9,'bye'],\n[3,7,8,9,'hello'],\n[3,5,8,9,'hi'],\n[31,5,4,9,'hi'],\n[3,7,8,5,'hello'],\n]\n\n# Create frame out of data\ndf = pd.DataFrame(data)\n\n# Name rows and columns\ndf.columns = ['Col0','Col1','Col2','Col3','Col4']\ndf.index = ['Row0','Row1','Row2','Row3','Row4','Row5']\n\nprint(df)\n\n      Col0  Col1  Col2  Col3   Col4\nRow0     2     4    -1     2  hello\nRow1     5     1     2     9    bye\nRow2     3     7     8     9  hello\nRow3     3     5     8     9     hi\nRow4    31     5     4     9     hi\nRow5     3     7     8     5  hello\n\n\nFor example, we can compute the minimum, maximum and average value by using the function min(), max() and mean(), respectively.\n\n# Minimum of the first column\nmin_col1 = df['Col1'].min()\n\nprint(min_col1)\n\n1\n\n\n\n# Maximum of the second column\nmax_col2 = df['Col2'].max()\n\nprint(max_col2)\n\n8\n\n\n\n# Mean of the zeroth column\nmean_col0 = df['Col0'].mean()\n\nprint(mean_col0)\n\n7.833333333333333\n\n\nIt is also possible to count occurrences of a given word (or number) using value_counts()[word]. For example, suppose we want to count how often the word 'hello' appears in the third column:\n\ncount_hello = df['Col4'].value_counts()['hello']\n\nprint(count_hello)\n\n3\n\n\nWe can also to more advanced things like counting the total number of occurrences of every word in the fourth column. By having a quick look at the data, we see that there are three distinct greetings, 'hello', 'hi' and 'bye', to be found in the fourth column. A quick way to obtain these greetings in a list is to use the unique() function. This function returns a list with all the unique entries found in the specified column.\n\ngreetings  = df['Col4'].unique()\n\nprint(greetings)\n\n['hello' 'bye' 'hi']\n\n\nNext, we can loop over the greetings in the list greetings and apply the value_counts() function to all of them. We store the results in a dictionary whose keys are the greetings in greetings and whose values are the number of times every greeting appears in the fourth column.\n\n# Create empty dictionary\noccur_count = {}\n\nfor i in greetings:\n    occur_count[i] = df.loc[:,'Col4'].value_counts()[i]\n\nprint(occur_count)\n\n{'hello': np.int64(3), 'bye': np.int64(1), 'hi': np.int64(2)}",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data handling with Pandas</span>"
    ]
  },
  {
    "objectID": "08-files-and-pandas.html#importing-and-exporting-data",
    "href": "08-files-and-pandas.html#importing-and-exporting-data",
    "title": "8  Data handling with Pandas",
    "section": "8.3 Importing and exporting data",
    "text": "8.3 Importing and exporting data\nData is typically provided in an external file, for example, a comma-separated values (CSV) file. You can download the data that was given at the beginning of this section here in and you should store in under the name dataset.csv.\n\ndf = pd.read_csv('dataset.csv')\n\nprint(df)\n\n     name   height (cm)   weight (kg)   age (years)  dietary preference\n0   Aiden           185            80            23              Veggie\n1   Bella           155            60            23              Veggie\n2  Carlos           190           100            23                None\n3   Dalia           185            85            21                None\n4   Elena           160            62            19               Vegan\n5  Farhan           170            75            25                None\n6   Geert           178            80            25              Veggie\n\n\nTo test the code above in Spyder, you need to store the Python file that you execute the code in, in the same folder as the file dataset.csv.\nThe function read_csv stores the data in the file dataset.csv. The first row of the data is assumed to contain the names of the columns. If the data file does not contain such a first row, we can import the data with the additional argument header=None, meaning that we tell Python that there is no first row containing the column names.\n\ndf = pd.read_csv('dataset.csv', header=None)\n\nprint(df)\n\n        0             1             2             3                    4\n0    name   height (cm)   weight (kg)   age (years)   dietary preference\n1   Aiden           185            80            23               Veggie\n2   Bella           155            60            23               Veggie\n3  Carlos           190           100            23                 None\n4   Dalia           185            85            21                 None\n5   Elena           160            62            19                Vegan\n6  Farhan           170            75            25                 None\n7   Geert           178            80            25               Veggie\n\n\nNote that in the code above, the first row of the data is now included in the data frame, instead of set to be the names of the columns. The columns are now indexed by integers like the rows of the frame.\nIt is also possible to export an (adjusted) data frame to a comma-separated file. Let us first add another row to the existing frame and then export it to a new file called new_dataset.csv.\n\ndf = pd.read_csv('dataset.csv')\n\n# Highest index in original frame is 5, so 6 is the index \n# at which we place the new row\ndf.loc[6] = ['Geert',178, 80, 25, 'Veggie']\n\nprint(df)\n\n     name   height (cm)   weight (kg)   age (years)  dietary preference\n0   Aiden           185            80            23              Veggie\n1   Bella           155            60            23              Veggie\n2  Carlos           190           100            23                None\n3   Dalia           185            85            21                None\n4   Elena           160            62            19               Vegan\n5  Farhan           170            75            25                None\n6   Geert           178            80            25              Veggie\n\n\nNow that we have added a new row, we can use the to_csv() function tho store the frame in the new comma-separated file.\n\ndf.to_csv('new_dataset.csv')\n\nThe folder in which you have stored the original dataset.csv file, as well as the Python file in which the code is executed, should now contain a new file called new_dataset.csv. If you open the file in, e.g., Notepad (Windows) or Excel, you will see something like the following figure.\n\n\n\nNew data frame in .csv file\n\n\nOn the first line the column names can be found, and on the following lines the data from the frame. However, Python also exported the row indices 0,1,\\dots,6. If you don’t want these indices to be included (they were also not contained in the original .csv file), you can use the argument index=False in to_csv().\n\ndf.to_csv('new_dataset_no_indices.csv', index=False)\n\nThis time the resulting file does not have the row indices at the beginning of every line.\n\n\n\nNew data frame without row indices in .csv file\n\n\nInstead of storing the data in a new file, we can also overwrite the original dataset.csv file.\n\ndf.to_csv('dataset.csv',index=False)\n\nYou should, however, be careful with overwriting files in this way. Always make sure you have a copy of the data stored somewhere else, in case something goes wrong!",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data handling with Pandas</span>"
    ]
  },
  {
    "objectID": "09-math-and-plotting.html",
    "href": "09-math-and-plotting.html",
    "title": "9  Mathematics and plotting",
    "section": "",
    "text": "9.1 Root finding\nIn this chapter we will see some mathematical algorithms from the scipy package (or module) as well as how to visualize data, e.g., some of the figures we have seen in earlier chapters, using matplotlib.\nSciPy is a package that can be used to perform various mathematical tasks and algorithms, making it very important for data analysis purposes. The Matplotlib package is essential in Python to create insightful visual representations of your data and the analysis you performed on it.\nWe first discuss two fundamental mathematical tasks: finding a root of a mathematical function and minimizing a mathematical function. After that, we will explain how to visualize data and mathematical functions.\nConsider the function f(x) = x^2 + 2x - 1. A visualization of this function is given below. We will learn how to create this figure ourselves in Section 9.3.\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-3, 3, 600)\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, f(x), label='$f(x) = x^2 + 2x - 1$')\n\n# Add labels and title\nplt.title('Plot of the function f on the interval [-3,3]')\nplt.xlabel('x')\nplt.ylabel('f(x)')\n\n# Add a grid\nplt.grid(True)\n\n# Set range\nplt.xlim(-3,3)\nplt.ylim(-4,14)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\nIn our case, we want to solve the equation x^2 + 2x -1 = 0. You might remember from your high school math course that, for given numbers a, b and c, the roots of the quadratic function f(x) = ax^2 + bx + c, are given by\nx_\\ell = \\frac{- b - \\sqrt{b^2 - 4ac}}{2a} \\ \\ \\text{ and } \\ \\ x_r = \\frac{- b + \\sqrt{b^2 - 4ac}}{2a}\nwhere the subscript \\ell is used to denote the fact that this will be the “left” root and r to denote the “right” root.\nFor f(x) = x^2 + 2x-1, we have a = 1, b = 2 and c = -1. Plugging in these values in the formula above gives x_\\ell = -1 - \\sqrt{2} \\approx - 2.4142 and x_r = -1 + \\sqrt{2} \\approx 0.4142. Although this is an easy way to find the roots of a quadratic function, we want to be able to find roots of any function f if they exist.\nThe easiest way to find a root of a general function is to use the the function fsolve() from the (sub)package scipy.optimize. This package contains many functions to carry out algorithmic tasks on mathematical functions. To avoid having to write scipy.optimize every time we will import this package under the name optimize, just as we did with NumPy where we used the line import numpy as np.\nBelow is the code snippet that carries out the root finding procedure.\n# Import package containing fsolve()\nimport scipy.optimize as optimize\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x - 1\n\n# Using fsolve() to find root of f\nguess = 3\nf_zero = optimize.fsolve(f,guess) \n\n# Print the found root\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by [0.41421356]\nIn chronological order, this code does the following:\nThe use of fsolve() requires some additional explanation. It takes two input arguments, the first one being a (mathematical) function f and the second one an initial guess for where a root of f might be, which we store in the variable guess. Note that you cannot reverse the order of the input arguments: f_zero = optimize.fsolve(guess,f) does not work!\nWe could also have used optimize.fsolve(f,3) instead of separately defining guess = 3 and then using guess as input argument. In coding, it is common practice to always define input data, the number 3 in this case, in a separate variable. Especially if the number would be used in multiple places in your code, this is useful.\nIt is important to observe that a Python function itself can be an input argument of another Python function! That is, the function f is an input argument of the function fsolve(). It is important to know that, to use a function f as an input fsolve(), it is required to define f as a Python function. That is, it is not possible to use the command optimize.fsolve(x**2 + 2*x - 1,guess).\nThe second input argument guess is needed by fsolve() to execute the underlying mathematical root finding method that is used to find a root of f. We do not go into the actual mathematical method that is being carried out in the background by Python when we execute fsolve()1, but the idea is that the method starts at the guess that we provide and then gradually finds its way to a root of f by doing various calculations.\nIn fact, the choice of initial guess can influence the outcome of fsolve(). That is, a different initial guess can lead the underlying mathematical method to a different root of the function. This is illustrated in the code below, where we find the other root -2.4142....\nguess = -2\nf_zero = optimize.fsolve(f,guess)\n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by [-2.41421356]\nAs you might have noted, the output of optimize.fsolve(f,guess) is a list containing one number, for example, the last piece of code returned [-2.41421356]. This happends because fsolve() can also be used to find roots of higher-dimensional functions, in which the case the root is a vector of numbers (stored in a list).\nIf you instead only want to output the number -2.41421356, i.e., the value of the element in the string, you can use optimize.fsolve(f,guess)[0] instead. This means that what is stored in f_zero is the 0-th (and only) element of the list optimize.fsolve(f,guess).\nguess = -2\nf_zero = optimize.fsolve(f,guess)[0]\n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by -2.414213562373095\nWe can also use root finding to solve other types of equations. Suppose we want to compute an x such that \nf(x) = 6.\nMoving the 6 to the left, we see that this is the same as computing an x such that f(x) - 6 = 0. Therefore, if we define the function g(x) := f(x) - 6, then an x that satisfies g(x) = 0 also satisfies f(x) = 6, and vice versa. Let us code this as well.\ndef g(x):\n    return f(x) - 6\n    \nguess = 4\nf_zero = optimize.fsolve(g,guess)[0]\n\nprint(\"A number x satisfying f(x) = 6, is given by\", f_zero)\n\nA number x satisfying f(x) = 6, is given by 1.82842712474619\nThe function g works as follows: It computes f(x) by running the function f with the input x, and then substracting 6 from it. Note that we could have also defined g by returning x**2 + 2x - 1 - 6. It is, however, more convenient to just write f(x) - 6 here, because we have already defined the function f earlier. Also, if we would change the definition of the function f, the function g is automatically updated as well.\nEverything we have seen up till now also allows us to write a general Python function to solve an equation of the form \nf(x) = c\n for a given function f and number c. In the example above, we had c = 6.\ndef solve_eq(f,c,guess):\n    \"\"\" \n    Input\n    ----------\n    f : A mathematical function taking as input a variable x,\n    c : The right hand side value of the equation f(x) = c,\n    guess : The initial guess for fsolve().\n    \n    Returns\n    -------\n    A value x solving f(x) = c.\n    \"\"\"\n\n    def g(x):\n        return f(x) - c\n    \n    x = optimize.fsolve(g,guess)[0]\n    return x\nThe function above takes as input the function f, the number c and an initial guess that fsolve() can use. Let us try out solve_eq() on some input data. The goal will be to solve the equation\n3x^2 -4x + 1 = 5.\n# We create the function h(x) = 3x^2 - 4x + 1 \ndef h(x):\n    return 3*x**2 - 4*x + 1\n\n# Right hand side of the equation h(x) = 5\nd = 5 \n\n# Our initial guess for fsolve() (we choose 1 here).\ninitial_guess = 1 \n\n# Print the found solution\nprint(\"A solution x to h(x) = d is given by\", solve_eq(h,d,guess))\n\nA solution x to h(x) = d is given by 2.0\nNote that the input arguments h, d and initial_guess need not have the same names as the local variables f, c guess in the function solve_eq(). What is important is that we input the arguments in the correct order in which we want them to be identified with the local variables. That is, by doing solve_eq(h,d,guess) Python knows that we want to assign the first input argument h to the first local variable f, the second input argument d to the second local variable c, and the third input argument initial_guess to the local variable guess.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "09-math-and-plotting.html#root-finding",
    "href": "09-math-and-plotting.html#root-finding",
    "title": "9  Mathematics and plotting",
    "section": "",
    "text": "NoteRoot finding\n\n\n\nA root x of a function f: \\mathbb{R} \\rightarrow \\mathbb{R} is a point that satisfies the equation f(x) = 0.\n\n\n\n\n\n\n\n\n\n\n\nImport the optimize (sub)package from the scipy package.\nDefine f(x) = x^2 + 2x -1 as a Python function (Chapter 6).\nUse optimize.fsolve(f,guess) so that Python knows that we want to use the function fsolve() from optimize.\nThe argument that is returned by fsolve() is assigned to the variable f_zero.\nPrint a message containing the root of f that was found.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "09-math-and-plotting.html#minimization",
    "href": "09-math-and-plotting.html#minimization",
    "title": "9  Mathematics and plotting",
    "section": "9.2 Minimization",
    "text": "9.2 Minimization\nAnother fundamental task in mathematics is to find the minimum value that a function can attain. Recall the function f(x) = x^2+2x-1 from the previous section.\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-3, 3, 600)\n\n# Define the absolute value function\ndef f(x):\n    return x**2 + 2*x -1\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, f(x), label='$f(x) = x^2 + 2x - 1$')\n\n# Add labels and title\nplt.title('Plot of the function f on the interval [-3,3]')\nplt.xlabel('x')\nplt.ylabel('f(x)')\n\n# Add a grid\nplt.grid(True)\n\n# Set range\nplt.xlim(-3,3)\nplt.ylim(-4,14)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n It can be seen that the point x at which the function f is the lowest, i.e., attains its minimum is x = -1, and the function values in that point is f(-1) = -2. Python has various ways of finding the minimum of a function, the easiest-to-use being fmin() from the optimize module.\nThe syntax that is used for this function is similar to that of fsolve(). Although we already defined the function f in the previous section, we will redefine it in the code below for sake of completeness.\n\nimport scipy.optimize as optimize\n\ndef f(x):\n    return x**2 + 2*x - 1\n    \nguess = 1\nminimum = optimize.fmin(f,guess)\n\nprint('The minimum of the function f is attained at x = ', minimum)\n\nOptimization terminated successfully.\n         Current function value: -2.000000\n         Iterations: 19\n         Function evaluations: 38\nThe minimum of the function f is attained at x =  [-1.]\n\n\nNote that Python outputs some information in the console about the mathematical optimization procedure that was performed in order to find the minimum of the function. It displays the function value at the miminum that was found, in our case -2 = f(-1), and a number of iterations and function evaluations. These last two pieces of information are not relevant for us, but are useful for an expert who wants to understand better how well the optimization procedure performed. If you want, you can suppress all this information by adding disp=False or disp=0 as an argument to the fmin() function. This is illustrated below.\n\nminimum = optimize.fmin(f,guess,disp=False)\n\nprint('The minimum of the function f is attained at x = ', minimum)\n\nThe minimum of the function f is attained at x =  [-1.]\n\n\nAlso here, if you want to return only the value -1.0 instead of the list [-1.0] you can do the following as we illustrated for fsolve() as well.\n\nminimum = optimize.fmin(f,guess,disp=False)[0]\n\nprint('The minimum of the function f is attained at x = ', minimum)\n\nThe minimum of the function f is attained at x =  -1.0000000000000018",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "09-math-and-plotting.html#sec-visualization",
    "href": "09-math-and-plotting.html#sec-visualization",
    "title": "9  Mathematics and plotting",
    "section": "9.3 Visualization",
    "text": "9.3 Visualization\nIn this section we will explain the basics for plotting functions and data, for which we will use the matplotlib.pyplot (sub)package. We import it under the name plt. You might wonder why we use the name plt and not the perhaps more obvious choise plot. This is because plot() is a command that we will be using, so we do not want to create any conflicts with this function when executing a Python script.\nIn this section we will explain step-by-step how to generate the figure that we have seen in the previous two sections. We start with plotting the function f(x) = x^2 + 2x -1 for some values of x in a two-dimensional figure.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n    \n# Define the x range of x-values\nx = np.array([-3,-2,-1,0,1,2,3])\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nYou can view the figure in the Plots pane (or tab) in Spyder.\n\nIf the resolution of the plots in the Plots pane is bad, you can increase it by going to “Tools &gt; Preferences &gt; IPython console &gt; Graphics &gt; Inline backend &gt; Resolution” and set the resolution to, for example, 300 dpi.\n\n\nYou can get the Plots pane in fullscreen by going to the button with the three horizontal lines in the top right corner and choose “Undock”. You can “Dock” the pane again as well if you want to leave the fullscreen mode.\n\n\n\n\nIPython Console\n\n\nWe will next explain what the code above is doing. After defining the function f, we create the vector (i.e., Numpy array) \nx = [x_1,x_2,x_3,x_4,x_5,x_6,x_7] =  [-3,-2,-1,0,1,2,3].\n\nWe then compute the function values f(x_i) for i = 1,\\dots,7 and store these in the vector y. This might seem a bit strange. We defined the vector f as being a function that takes as input a number x and outputs the number f(x), but now we are inputting a whole vector of numbers x into the function f. Python is capable of handling this, and deals with this by returning the function value for every element of the vector x. That is, it will output the vector\n\n[f(x_1),f(x_2),f(x_3),f(x_4),f(x_5),f(x_6),f(x_7)] = [2,-1,-2,-1,2,7,14].\n\nWe call f a vectorized function: At first glance, it is defined to have a single number as input, but it can also handle a vector as input, in which case it returns the function evaluation for every element of the vector. This typically only works when x is defined to be a Numpy array. If we would have defined x = [-3,-2,-1,0,1,2,3] as a list of numbers, the code would have given an error (try this yourself!).\n\nIf you use mathematical functions or functions from Numpy, Scipy or Matplotlib, it is best to store numerical input data for these functions in Numpy arrays (and not lists).\n\nNext, we create an (empty) figure using the command plt.figure(). Then comes the most important command, plt.plot(x,y), that plots the elements in the vector x against the elements in the vector y = f(x), and connects consecutive combinations (x_i,y_i) and (x_{i+1},y_{i+1}) with a line segment. For example, we have (x_1,y_1) = (-3,2) and (x_2,y_2) = (-2,-1). The left most line segment is formed by connecting these points.\nIf you only want to plot the points (x_i,y_i), and not the line segments, you can use plt.scatter(x,y) instead of plt.plot(x,y).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n    \n# Define the x range of x-values\nx = np.array([-3,-2,-1,0,1,2,3])\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.scatter(x, y)\n\n\n\n\n\n\n\n\n Observe that the (blue) line in the figure that was generated using plt.plot(x,y) is not as “smooth” as in the figures in the previous sections, where the function does not (visibly) have these segments. To get a smoother function line, we can include more points in the vector x.\nA quick way to generate a number k of evenly spaced points in the interval [a,b] is the command np.linspace(a,b,k) from the Numpy package. It takes as input the bounds of the interval [a,b] and the number of points k that we want to have in it. Consider the following example, where we want to generate k = 11 points in the interval [a,b] = [0,1].\n\nimport numpy as np\n\nx = np.linspace(0,1,11)\n\nprint(x)\n\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]\n\n\nNote that the end points of the interval form the first and last element in the vector x. “Evenly spaced” refers to the fact that the distance between two consecutive points in x is always the same. For this x this common distance is 0.1 = (b-a)/(k-1).\nLet us plot again the function f, but this time with 600 elements in x in the interval [-3,3]. We use plt.plot() again, instead of plt.scatter(). We now obtain a much smoother function line.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n    \n# Define the x range of x-values\nx = np.linspace(-3,3,600)\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y)\n\n\n\n\n\n\n\n\n You can add a legend for the line/points that you plot by using the label argument of plt.plot(). For example we can add the function description using plt.plot(x,y,label='$f(x) = x^2 + 2x - 1$').\n\n\n\n\n\n\nNote\n\n\n\nIf you want to add a superscript in a label, you should use the ^ symbol, as opposed to ** which you should use if you want to do an actual numerical computation with exponentiation.\n\n\nThis is in particular useful if you plot multiple functions in one figure, as the example below illustrates. There we plot the functions f and g, with g(x) = 3x a new function. To have the labels appear in the legend of the figure, you need to add a legend to the figure with plt.legend().\nIf you want to add labels to the horizontal and vertical axis, you can use the commands plt.xlabel() and plt.ylabel().\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Define the function g\ndef g(x):\n    return 3*x\n    \n# Define the x range of x-values\nx = np.linspace(-3,3,600)\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\nz = g(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y, label='$f(x) = x^2 + 2x - 1$')\nplt.plot(x, z, label='$g(x) = 3x$')\n\n# Create labels for axes\nplt.xlabel('x')\nplt.ylabel('Function value')\n\n# Create the legend with the specified labels\nplt.legend()\n\n\n\n\n\n\n\n\n You might observe that the range on the vertical axis changed now that we added a second function to the plot. When we only plotted the function f, the vertical axis ranged from -2 to 14, but now with the function g added to it, it ranges from -10 to 15.\nYou can fix the range [c,d] on the vertical axis using the command plt.ylim(c,d), and to fix the range of the horizontal axis to [a,b], you can use plt.xlim(a,b). In the figure below, we fix the vertical range to [c,d] = [-10,14] and the horizontal axis to [a,b] = [-3,3].\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Define the function g\ndef g(x):\n    return 3*x\n    \n# Define the x range of x-values\nx = np.linspace(-3,3,600)\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\nz = g(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y, label='$f(x) = x^2 + 2x - 1$')\nplt.plot(x, z, label='$g(x) = 3x$')\n\n# Create labels for axes\nplt.xlabel('x')\nplt.ylabel('Function value')\n\n# Create the legend with the specified labels\nplt.legend()\n\n# Fix the range of the axes\nplt.xlim(-3,3)\nplt.ylim(-10,14)\n\n\n\n\n\n\n\n\n Finally, you can also add a title to the plot using the command plt.title() as well as a grid in the background of the figure using plt.grid(). These are illustrated in the figure below.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Define the function g\ndef g(x):\n    return 3*x\n    \n# Define the x range of x-values\nx = np.linspace(-3,3,600)\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\nz = g(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y, label='$f(x) = x^2 + 2x - 1$')\nplt.plot(x, z, label='$g(x) = 3x$')\n\n# Create labels for axes\nplt.xlabel('x')\nplt.ylabel('Function value')\n\n# Create the legend with the specified labels\nplt.legend()\n\n# Fix the range of the axes\nplt.xlim(-3,3)\nplt.ylim(-10,14)\n\n# Add title to the plot\nplt.title('A first plot in Python of two functions')\n\n# Add grid to the background\nplt.grid()\n\n\n\n\n\n\n\n\n This completes the description of how to plot figures like those we saw in the previous two sections. As a final remark, there are many more plotting options that we do not cover here. For example, with the plt.xticks() and plt.yticks() commands you can specify the numbers you want to have displayed on the horizontal and vertical axis, respectively. Also, there are commands to specify line color, width, type (e.g., dashed) and much more! You do not need to know this, but feel free to play around with such commands!",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "09-math-and-plotting.html#footnotes",
    "href": "09-math-and-plotting.html#footnotes",
    "title": "9  Mathematics and plotting",
    "section": "",
    "text": "In fact, there exist many root finding methods. A very famous one is Newton’s method developed by Isaac Newton, a famous sciencist that you might have heard of. The reason why there are so many root finding methods is that some work better than others on a given function f. There are other ways to do root finding in Python that allow you to specify a root finding method yourself, but this is a more advanced topic beyond the scope of this course.↩︎",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "10-object-oriented-programming.html",
    "href": "10-object-oriented-programming.html",
    "title": "10  Object oriented programming",
    "section": "",
    "text": "10.1 Attributes\nPython is what is called an object oriented programming language. Almost everything in Python is an object on which, e.g., functions can be applied. Recall, for example, the Pandas data frames that we say in the last chapter: We could change elements in the frame, compute summary statistics of its columns, and modify its size.\nObjects in Python are generated as instances of a class. Even something simple as a decimal number is an object from a class. To figure out what class an object is from, you can use the type() function.\nTo illustrate the concept of a class in more detail, we will create a class whose objects model students. The class could, for example, be used to keep track of the student administration at a school or university. You should think of a class as a blueprint: It describes the type of information we keep track of of every student, and how we can retrieve and manipulate it. The basic syntax for creating a class is given by class class_name:. For example if we want to create an (empty) class called Student we can do the following\nThe pass command here is used because there is no further code in this class. You could use it as a kind of temporary place holder if you know you are going to create a class, but have not yet code to place into it.\nIn general, to create an object of a class we need to have some basic information of the object. For example, we can require that every student needs to have a name, age and student number. These pieces of information, needed to create an object of the class, are called attributes. We use a special function in Python called __init__(), that can be used to so-called initialize an object. For the student class with attributes name, age and student number (ID), this is done as follows.\nclass Student:\n    # This function initializes an object of the class Student\n    # by setting the attributes (name, age and ID) of an object.   \n    def __init__(self,name,age,student_number):\n        self.name = name\n        self.age = age\n        self.ID = student_number\nIn general, the __init__() function has a first input called self which you should think of as representing an empty object that we are going to fill with the student’s information. The other input arguments of __init__() are the inputs for the attributes of the student.\nThe attributes we set by doing self.attribute_name = attribute_input, where attribute_name is the name of the attribute (name, age and ID) here and attribute_input the input arguments of the function __init__() (name, age and student_number here).\nNote that the variables we use for the input arguments of __init__() do not have to be the same as the names of the attributes themselves. For example, for the student number, we use the input argument student_number in __init__(), but we set this argument to be the ID attribute (when we do self.ID = student_number).\nWe next create an object (i.e., student) of the class with given inputs for the attributes.\n# Creating an object (called stud) of the class Student\nstudent1 = Student(\"Aidan\",19,\"2029912\")\n\n# Print attributes of the object\nprint(\"Name of student is\", student1.name)\nprint(\"Age of student is\", student1.age) \nprint(\"Student number of student is\", student1.ID) \n\nName of student is Aidan\nAge of student is 19\nStudent number of student is 2029912\nThe line student1 = Student(\"Aidan\",19,\"2029912\") creates an object (or instance) of the Student class called student1. The input arguments of Student(\"Aidan\",19,\"2029912\") are automatically passed to the (by every class required) __init__() function, that is, name = \"Aidan\", age=19, and student_number=\"2029912\". You should think of student1 becoming the local variable self in the __init__() function.\nIt is also possible to, after an object has been created, change its attributes.\n# Add last name of student as well\nstudent1.name = \"Aidan Amir\"\n\nprint(student1.name)\n\nAidan Amir",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Object oriented programming</span>"
    ]
  },
  {
    "objectID": "10-object-oriented-programming.html#methods",
    "href": "10-object-oriented-programming.html#methods",
    "title": "10  Object oriented programming",
    "section": "10.2 Methods",
    "text": "10.2 Methods\nIn a class we define, next to __init__(), additional functions that can be used to used to modify or obtain information of the student. Such function in a class are called methods. The __init__() function is also strictly speaking a method of the class.\nAs a first example, suppose we want to check if a student is of adult age (18 years or older). We can do this by adding the method adult() to the Student class. The first input of such an additional function always should be self. Next to that, there could also be additional arguments (we will give an example of this later).\nNote that there is a difference between how we access attributes and how we apply methods: Attributes are accessed using object_name.attribute_name, but functions are applied with object_name.method_name(), i.e., with brackets () at the end.\n\nclass Student:\n    # This method initializes an object of the class Student\n    # by setting the attributes (name, age, and ID) of an object.   \n    def __init__(self, name, age, student_number):\n        self.name = name\n        self.age = age\n        self.ID = student_number \n\n    def adult(self):\n        if self.age &gt;= 18:\n            return print(self.name,\"is an adult\")\n        else:\n            return print(self.name,\"is not an adult\")\n\n\n# Create two Student objects\nstudent1 = Student(\"Aidan\",19,\"2029912\")\nstudent2 = Student(\"Bella\",17,\"2034912\")\n\n# Check whether students are adults\nstudent1.adult()\nstudent2.adult()\n\nAidan is an adult\nBella is not an adult\n\n\n\n10.2.1 Input arguments\nWe also give an example of a method that takes additional input arguments (next to self). Suppose we have a list of student numbers that have registered for the exam of a course. We create a method reg_check that takes as input the list of student numbers and checks whether a student (i.e., object) has registered or not by inspecting whether or not the student number of the student is contained in the list.\n\nclass Student:\n    # This method initializes an object of the class Student\n    # by setting the attributes (name, age, and ID) of an object.   \n    def __init__(self, name, age, student_number):\n        self.name = name\n        self.age = age\n        self.ID = student_number \n\n    def adult(self):\n        if self.age &gt;= 18:\n            return print(self.name,\"is an adult\")\n        else:\n            return print(self.name,\"is not an adult\")\n    \n    def reg_check(self,registrations):\n        for i in registrations:\n            if(i == self.ID):\n                return print(self.name, \"is registered\")\n        return print(self.name, \"is not registered\")\n\n\nstudent1 = Student(\"Aidan\",19,\"2029912\")\n\ncourse_A = [\"2034757\",\"2029912\",\"2087645\",\"2091234\",\"2198765\"]\ncourse_B = [\"2034757\",\"2029915\",\"2087645\",\"2091234\",\"2198765\"]\n\n# Aidan's student number is contained in list of exam course A\nstudent1.reg_check(course_A)\n\n# Aidan's student number is not contained in list of exam course B\nstudent1.reg_check(course_B)\n\nAidan is registered\nAidan is not registered\n\n\n\n\n10.2.2 Updating attributes\nWe can also include more involved attributes in a class. For example, suppose that we want to be able to keep track of the courses that a student is taking part in. To achieve this, we create an extra attribute courses that is initialized as an empty list in __init__(). In addition to this, we define a method addCourse() that allows us to append a course to the courses list. We temporarily remove the methods age and reg_check to not make the code too long.\n\nclass Student:\n    # This method initializes an object of the class Student\n    # by setting the attributes (name, age, and ID) of an object.   \n    def __init__(self, name, age, student_number):\n        self.name = name\n        self.age = age\n        self.ID = student_number \n        self.courses = []\n\n    def addCourse(self,course_name):\n        return self.courses.append(course_name)\n\nNote that the courses attribute is not obtained from an input argument of __init__(). This is because we define it to be an empty list.\n\nstudent1 = Student(\"Aidan\",19,\"2029912\")\n\n# Initially the courses list is empty\nprint(student1.courses)\n\n# Add course Programming\nstudent1.addCourse(\"Programming\")\nprint(student1.courses)\n\n# Add course Linear Algebra\nstudent1.addCourse(\"Linear Algebra\")\nprint(student1.courses)\n\n[]\n['Programming']\n['Programming', 'Linear Algebra']\n\n\nSimilarly, we can also define a method that can be used to delete a course. Deleting an element from a list can be done using the remove function, that is illustrated below.\n\nx = ['Aidan','Bella','Charlie']\nx.remove('Bella')\n\nprint(x)\n\n['Aidan', 'Charlie']\n\n\nNext, we give the class with the addition and deletion method for courses.\n\nclass Student:\n    # This method initializes an object of the class Student\n    # by setting the attributes (name, age, and ID) of an object.   \n    def __init__(self, name, age, student_number):\n        self.name = name\n        self.age = age\n        self.ID = student_number \n        self.courses = []\n\n    # This method adds a course to the list courses\n    def addCourse(self,course_name):\n        return self.courses.append(course_name)\n\n    # This method deletes a course from the list courses\n    def delCourse(self,course_name):\n        return self.courses.remove(course_name)\n\n\nstudent1 = Student(\"Aidan\",19,\"2029912\")\n\n# Initially the courses list is empty\nprint(student1.courses)\n\n# Add course Programming\nstudent1.addCourse(\"Programming\")\nprint(student1.courses)\n\n# Add course Linear Algebra\nstudent1.addCourse(\"Linear Algebra\")\nprint(student1.courses)\n\n# Delete course Programming\nstudent1.delCourse(\"Programming\")\nprint(student1.courses)\n\n[]\n['Programming']\n['Programming', 'Linear Algebra']\n['Linear Algebra']\n\n\n\n\n10.2.3 Overview\nTo summarize, a class consists of an initialization method __init__() that is mandatory and used to initialize objects/instances of a class by setting the attributes of an object. Next to that, there can be other methods that either can be used to manipulate and/or to derive properties of an object.\nWe can summarize the aspects of the Student class as follows.\n\n\n\n\n\n\n\nclass\nStudent\n\n\n\n\nAttributes\nname, age, student number, courses\n\n\nMethods\ninitialization, check age, check registration\n\n\n\nadd course, delete course\n\n\n\n\n# Import packages here if needed\n# ...\n\n# Define class with all its methods here\nclass Student:\n    # This method initializes an object of the class Student\n    # by setting the attributes (name, age, and ID) of an object.   \n    def __init__(self, name, age, student_number):\n        self.name = name\n        self.age = age\n        self.ID = student_number \n        self.courses = []\n\n    # This method check if student is &gt;= 18\n    def adult(self):\n        if self.age &gt;= 18:\n            return print(self.name,\"is an adult\")\n        else:\n            return print(self.name,\"is not an adult\")\n    \n    # This method checks if ID is included in list registrations\n    def reg_check(self,registrations):\n        for i in registrations:\n            if(i == self.ID):\n                return print(self.name, \"is registered\")\n        return print(self.name, \"is not registered\")\n    \n    # This method adds a course to the list courses\n    def addCourse(self,course_name):\n        return self.courses.append(course_name)\n\n    # This method deletes a course from the list courses\n    def delCourse(self,course_name):\n        return self.courses.remove(course_name)\n\n# Put here code to initialize objects.\nstudent1 = Student(\"Aidan\",19,\"2029912\")\n\n# Print attributes or test methods \n# ...\n\nIt is important to separate your testing code from the class. All the methods that form the class have to be indented under the class Student: line. Testing code should come afterwards (when the complete class has been defined).\nFurthermore, you have to be aware of the difference in syntax between accessing an attribute of an object, or applying a method to it.\n\n# Print attributes with object_name.attribute_name \n# and NOT object_name.attribute_name()\nprint(student1.name) # Not print(student1.name())\n\n# Apply method with object_name.method_name() \n# and NOT object_name.method_name. The brackets () indicate \n# that you are applying a method. Additional input arguments \n# of the method are put in the brackets.\nstudent1.adult()\n\n# Note that for the line above we don't use the print() statement, \n# because the adult() method itself returns a print() statement.\n\nAidan\nAidan is an adult",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Object oriented programming</span>"
    ]
  },
  {
    "objectID": "10-object-oriented-programming.html#inheritance",
    "href": "10-object-oriented-programming.html#inheritance",
    "title": "10  Object oriented programming",
    "section": "10.3 Inheritance",
    "text": "10.3 Inheritance\nIn Python you can also build classes on top of each other, so that the new class inherit the attributes and methods of an old class. Suppose we start with a simple class Person, whose objects are people that have a name and age. There is also a method in this class that checks whether someone is an adult (18 years or older).\n\nclass Person:\n    # Initialize a person\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    # Check if person is an adult\n    def adult(self):\n        if(self.age &gt;= 18):\n            return print(self.name, \"is an adult\")\n        else:\n            return print(self.name, \"is not an adult\")\n\n\nperson1 = Person(\"Bella\", 19)\n\n# Check if Bella is an adult\nperson1.adult()\n\nBella is an adult\n\n\nSuppose we now also want to create a class Student, where every student object has the attributes name, age and student number. We can do this by defining this class from scratch, but we can also make more clever use of the class Person that we already have created. Note that in terms of attributes, every student (having age, name and student number) can be seen as a special case of a person (having age and name), but not the other way around. In this case, we call Person the parent class and Student the child class.\nIt is possible to define the class Student so that it automatically inherits the attributes and methods of the class Person. To achieve this, we should put the parent class in brackets of the new child class that we want to define, so in our case we should define the Student class using class Student(Person). Let us do this with Python code as well, where we in addition also set the student number as attribute.\n\nclass Student(Person):\n    # Initialize a student\n    def __init__(self, name, age, student_number):\n        Person.__init__(self,name,age)\n        self.ID = student_number\n\nThe class Student also needs an __init__() method, which takes as input all the attributes that we want to set (age, name and student number). Instead of using self.name = name and self.age = age to set the name and age of a student, we call the __init__() function from the Person class with the line Person.__init__(self,name,age) with arguments name and age.\nYou could, of course, argue that we might as well have typed self.name = name and self.age = age here, but you should imagine that objects in Python can have hundreds of attributes. If you are building classes on top of each other with this number of attributes, calling the initialization method from a parent class is much more efficient than setting all the attributes of an object from a child class explicitly again.\nAfter having created an object from the class Person with the line Person.__init__(self,name,age), theryby setting the name and age of the student, we, in addition, set the student number with self.ID = student_number.\n\nstudent1 = Student(\"Bella\",19,\"20143576\")\n\nprint(student1.name, student1.age, student1.ID)\n\nBella 19 20143576\n\n\nWe can also check is the student is an adult by using the adult() method from the class Person. Because we defined the class Student to be the child of the parent class Person, we can use this method right away also on objects of the class Student.\n\n# Check if Bella is an adult\nstudent1.adult()\n\nBella is an adult",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Object oriented programming</span>"
    ]
  },
  {
    "objectID": "10-object-oriented-programming.html#mathematical-example",
    "href": "10-object-oriented-programming.html#mathematical-example",
    "title": "10  Object oriented programming",
    "section": "10.4 Mathematical example",
    "text": "10.4 Mathematical example\nIn this section we will define a class whose objects are two-dimension rectangles in the two-dimensional plane \\mathbb{R}^2, and we define some methods do derive properties from these rectangles. An example of a rectangle in \\mathbb{R}^2, with corner points (1,3), (4,3), (4,1), (1,1) is given below.\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx_coord = [1,4,4,1,1]\ny_coord = [1,1,3,3,1]\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x_coord, y_coord,linewidth=3)\n\n# Add labels and title\nplt.title('A rectangle with corners $(1,3), (4,3), (4,1), (1,1)$')\n\n# Add a grid\nplt.grid(True)\n\n# Set range\nplt.xlim(0,5)\nplt.ylim(0,4)\n\n# Set ticks\nplt.xticks([0,1,2,3,4,5])\nplt.yticks([0,1,2,3,4])\n\n# Show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\nTo keep things simple, we assume that the rectangles never appear at an angle, but always with the horizontal and vertical sides parallel to the horizontal and vertical axis, respectively.\nWe should first think about how we want to represent a rectangle in Python, i.e., what will the attributes of a rectangle object of the class be? There are many possibilities here, for example, we could explicitly choose four corner points, that together form the rectangle, as its attributes. This would require eight input numbers: four x-coordinates and four y-coordinates.\nA more efficient way of doing this is to store the coordinates of the upper-left corner point, the height, and the width of the rectangle (only four input numbers). In the example above the upper-left corner point is (4,1), the height of the rectangle is 2, and the width is 3. Note that this information is enough to derive the locations of the other corner points, i.e., (4+\\text{width},1), (4,1-\\text{height}), (4 + \\text{width},1 - \\text{height}).\n\nclass Rectangle:\n    # Here corner is the upper-left corner point which \n    # should be a list containing the x- and y-coordinate.\n    def __init__(self, corner, height, width):\n        self.corner= corner\n        self.height = height\n        self.width = width\n\nNote that we assume that the upper left corner is given in a list whose first entry is the x-coordinate of the upper left corner, and whose second entry is the y-coordinate. This is merely a modeling choice; we could also have defined two separate attributes for the x- and y-coordinate.\n\nrectangle1 = Rectangle([1,3],2,3)\n\n# Print upper left corner of the rectangle\nprint(rectangle1.corner)\n\n[1, 3]\n\n\n\n10.4.1 Methods\nWe will next define three methods that can be used to compute explicitly the corner points of the rectangle, its area and its circumference.\nLet us start with the area (width times height) and circumference (two times width plus two times height) of the rectangle. Note that these are relatively straightforward to compute these given that the width and height of a rectangle object are two of its attributes.\n\nclass Rectangle:\n    # Here corner is the upper-left corner point which \n    # should be a list containing the x- and y-coordinate.\n    def __init__(self, corner, height, width):\n        self.corner= corner\n        self.height = height\n        self.width = width\n    \n    # Compute area\n    def area(self):\n        return self.width*self.height\n\n    # Compute circumference\n    def circumference(self):\n        return 2*self.width + 2*self.height\n\n\nrectangle1 = Rectangle([1,3],2,3)\n\n# Compute and print list of corner points of the rectangle\narea1 = rectangle1.area()\ncircumference1 = rectangle1.circumference()\n\nprint(\"The area of the rectange is\", area1)\nprint(\"The circumference of the rectange is\", circumference1)\n\nThe area of the rectange is 6\nThe circumference of the rectange is 10\n\n\nWe continue with the corner points method corners(); we leave out the area and circumference method from the code to keep the code snippet short.\nIf we know that the left upper corner point is located at [x,y] then the upper-right corner is [x + \\text{width},y], the lower-right corner [x + \\text{width},y - \\text{height}], and the lower-left corner [x,y - \\text{height}]. We will write a method that returns these points, including the upper-left corner, in a list (restulting in a list of lists as all the corner points themselves will be lists of two elements).\n\nclass Rectangle:\n    # Here corner is the upper-left corner point which \n    # should be a list containing the x- and y-coordinate.\n    def __init__(self, corner, height, width):\n        self.corner= corner\n        self.height = height\n        self.width = width\n    \n    # Compute corner points: the output has the points in the \n    # order [upper-left, upper-right, lower-right, lower-left]\n    def corners(self):\n        up_right = [self.corner[0] + self.width, self.corner[1]]\n        low_right=[self.corner[0]+self.width,self.corner[1]-self.height]\n        low_left = [self.corner[0],  self.corner[1] - self.height]       \n        return [self.corner, up_right, low_right, low_left]\n\n\nrectangle1 = Rectangle([1,3],2,3)\n\n# Compute and print list of corner points of the rectangle\ncorners1 = rectangle1.corners()\nprint(corners1)\n\n[[1, 3], [4, 3], [4, 1], [1, 1]]\n\n\n\n\n10.4.2 Plotting method\nWe conclude this section with a method that can be used to plot a rectangle in a two-dimension plane, like the figure given at the beginning of this section. For the plotting method, we also make use of the method to determine the corner points, so this is included in the class below as well. The following code will be explained below.\n\nimport matplotlib.pyplot as plt\n\nclass Rectangle:\n    # Here corner is the upper-left corner point which \n    # should be a list containing the x- and y-coordinate.\n    def __init__(self, corner, height, width):\n        self.corner= corner\n        self.height = height\n        self.width = width\n    \n    # Compute corner points: the output has the points in the \n    # order [upper-left, upper-right, lower-right, lower-left]\n    def corners(self):\n        up_right = [self.corner[0] + self.width, self.corner[1]]\n        low_right=[self.corner[0]+self.width,self.corner[1]-self.height]\n        low_left = [self.corner[0],  self.corner[1] - self.height]       \n        return [self.corner, up_right, low_right, low_left]\n    \n    # Plot the rectangle\n    def plotting(self):\n        plt.figure()\n        \n        # Obtain corner points of the rectangle using corners()\n        c = self.corners()\n        \n        # Define two lists: x-coordinates and y-coordinates\n        x_coord = [c[0][0],c[1][0],c[2][0],c[3][0],c[0][0]]\n        y_coord = [c[0][1],c[1][1],c[2][1],c[3][1],c[0][1]]\n        \n        # Define ranges (margin of 3 around the rectangle)\n        plt.xlim(self.corner[0]-3,self.corner[0] + self.width + 3)\n        plt.ylim(self.corner[1]- self.height - 3,self.corner[1] + 3)\n\n        # Create the plot\n        plt.plot(x_coord, y_coord)\n        return\n\n\nrectangle1 = Rectangle([1,3],2,3)\n\n# Corner points of the rectangle\ncorners1 = rectangle1.corners()\nprint(corners1)\n\n# Plot the rectangle\nrectangle1.plotting()\n\n[[1, 3], [4, 3], [4, 1], [1, 1]]\n\n\n\n\n\n\n\n\n\n\nTo be able to plot, we first import the matplotlib.pyplot package under the usual alias plt. We then define the class Rectangle, whose __init__() and corners methods are the same as before.\nWe continue with explaining the plotting() method. The method first creates an empty figure using plt.figure() and determines the corner points of the rectangle using the corners() method. They are stored stored in the variable c. Because c is a list of lists, we can access the x-coordinate of the i-th corner point in the list with c[i][0], and the y-coordinate with c[i][1].\nRecall that the plot() function plots two lists/arrays x = [x_1,\\dots,x_n] and y = [y_1,\\dots,y_n] against each other by plotting the points (x_i,y_i) and then connecting them with line segments. To plot a rectangle, we therefore define\n\nx = [x_{\\text{upper-left}},x_{\\text{upper-right}},x_{\\text{lower-right}},x_{\\text{lower-left}},x_{\\text{upper-left}}]\n in the list x_coord and \ny = [y_{\\text{upper-left}},y_{\\text{upper-right}},y_{\\text{lower-right}},y_{\\text{lower-left}},y_{\\text{upper-left}}].\n in the list y_coord.\nNote that the command plt.plot(x_coord,y_coord) first draws the point (x_{\\text{upper-left}},y_{\\text{upper-left}}), then (x_{\\text{upper-right}},y_{\\text{upper-right}}), etc. and connects them. It is important that we include the upper-left point at the end again so that the left vertical side of the rectangle is drawn as well.\nFinally, we also set the range of the horizontal and vertical axis with the xlim() and ylim() functions. We include a margin of 3 around the box. To see how this works for the horizontal axis, note that self.corner[0] contains the x-coordinate of the upper-left point, and self.corner[0] + width that of the upper-right point. Therefore, to create a margin of 3 on both sides of the rectangle, we let the hortizontal axis range from self.corner[0] - 3 to self.corner[0] + width + 3.\n\n\n10.4.3 Overview\nThe complete class of the previous subsections, containing all the methods that we set up, is given below.\n\nimport matplotlib.pyplot as plt\n\nclass Rectangle:\n    # Here corner is the upper-left corner point which \n    # should be a list containing the x- and y-coordinate.\n    def __init__(self, corner, height, width):\n        self.corner= corner\n        self.height = height\n        self.width = width\n\n    # Compute area\n    def area(self):\n        return self.width*self.height\n\n    # Compute circumference\n    def circumference(self):\n        return 2*self.width + 2*self.height\n        \n    # Compute corner points: the output has the points in the \n    # order [upper-left, upper-right, lower-right, lower-left]\n    def corners(self):\n        up_right = [self.corner[0] + self.width, self.corner[1]]\n        low_right=[self.corner[0]+self.width,self.corner[1]-self.height]\n        low_left = [self.corner[0],  self.corner[1] - self.height]       \n        return [self.corner, up_right, low_right, low_left]\n    \n    # Plot the rectangle    \n    def plotting(self):\n        plt.figure()\n        \n        # Obtain corner points of the rectangle using corners()\n        c = self.corners()\n        \n        # Define two lists: x-coordinates and y-coordinates\n        x_coord = [c[0][0],c[1][0],c[2][0],c[3][0],c[0][0]]\n        y_coord = [c[0][1],c[1][1],c[2][1],c[3][1],c[0][1]]\n        \n        # Define ranges (margin of 3 around the rectangle)\n        plt.xlim(self.corner[0]-3,self.corner[0] + self.width + 3)\n        plt.ylim(self.corner[1]- self.height - 3,self.corner[1] + 3)\n\n        # Create the plot\n        plt.plot(x_coord, y_coord)\n        return",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Object oriented programming</span>"
    ]
  },
  {
    "objectID": "11-errors-and-debugging.html",
    "href": "11-errors-and-debugging.html",
    "title": "11  Errors and debugging",
    "section": "",
    "text": "11.1 Error types\nWhile writing Python scripts, you probably have encountered the situation that Python returned an error message, indicating that there is something wrong with your code. When writing a script from scratch this will often happen. Roughly speaking, most of the time that you spend on creating a working Python script goes into correcting errors in the first draft of your code. This process is called debugging.\nIn this chapter we will discuss different types of errors that Python might return, as well as some general strategies that you might adopt in order to efficienctly debug your code.\nThe three main types of errors that can occurs in Python are syntax, runtime and logical errors. We will give some examples of each of these three errors in the coming subsections.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Errors and debugging</span>"
    ]
  },
  {
    "objectID": "11-errors-and-debugging.html#error-types",
    "href": "11-errors-and-debugging.html#error-types",
    "title": "11  Errors and debugging",
    "section": "",
    "text": "11.1.1 Syntax error\nA syntax error occurs when Python does not understand the words or characters, i.e., syntax, that you use in your code. In more technical terms, Python is unable to interpret the code that you wrote because you did not use the correct syntax.\n\nx = \"Hello'\n\n\n\n\nSyntaxError\n\n\nIn the example above, we define a string x, but on the left we use a double quote and on the right a single quote. This is not correct, we should either use double quotes or single quotes on both sides. The output message indicates that the error occurs on the first line of the code, although the term “unterminated string literal” might not directly make sense to you.\nRoughly speaking, Python tries say you started the creation of a string by using the double quotes at the beginning, and is therefore expecting the string to be concluded somewhere as well with double quotes, but this never happens. The code should have been as follows.\n\nx = \"Hello\"\n\nSometimes it is more obvious what is going wrong in your code. In the example above, Python raises an error saying that the colon : is missing, which is needed in order to define a function in Python.\n\n# Define the function f(x) = x^2\ndef f(x)\n    return x**2\n\n\n\n\nSyntaxError\n\n\nThe code should have been as follows.\n\n# Define the function f(x) = x^2\ndef f(x):\n    return x**2\n\n\n\n11.1.2 Runtime error\nA runtime error occurs when Python runs (or executes) your code, but cannot create any output because the operations you try to perform on the variables that you defined are not possible. These errors are typically trickier than syntax errors: It might be that on some input data, your code does exactly what you want it to do, but on other input data it is not able to execute your code.\nConsider the example below where we define a division function that takes as input two numbers a and b, and returns a/b.\n\ndef division(a,b):\n    return a/b\n    \na = 1\nb = 3\nc = division(a,b)\n\nprint(c)\n\n0.3333333333333333\n\n\nThis function works perfectly fine for the inputs a = 1 and b = 3. However, if we we would take b = 0, then Python raises a ZeroDivisionError, which indicates that we are trying to divide by 0, which is mathematically not possible.\n\ndef division(a,b):\n    return a/b\n    \na = 1\nb = 0\nc = division(a,b)\n\nprint(c)\n\n\n\n\nZeroDivisionError\n\n\nAnother common runtime error in the context of functions is a TypeError. Such an errors occur when, you do not provide the correct number of input arguments for a function. In the code below, we have forgotten to input the second variable b that the function division() requires.\n\ndef division(a,b):\n    return a/b\n    \nd = 1\ne = 3\nf = division(d)\n\nprint(c)\n\n\n\n\nTypeError\n\n\nIn the context of indexing or accessing data in, e.g., a list, a common runtime error is the IndexError. Such an error occurs when you are, for example, trying to access an element of a string that does not exist. In the example below the list x has four elements. Since Python starts counting indices at 0, we have x[0] = 2, x[1] = 1, x[2] = 6 and x[3] = 8. Therefore, x[4] does not exist and so Python is not able to access it.\n\nx = [2,1,6,8]\n\nprint(x[4])\n\n\n\n\nIndexError\n\n\nFor scripts with classes, a common runtime error is an AttributeError which occurs if you are trying to access an attribute of an object that does not exist. In the below example, every student object has attributes name and age, but not ID. The code executes correctly up to the last line, but the last line itself gives an error.\n\nclass Student:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n\nstudent1 = Student(\"Aidan\",19)\nprint(student1.ID)  # ID attribute does not exist\n\n\n\n\nAttributeError\n\n\n\n\n11.1.3 Logical error\nArguably the most difficult to deal with are logical errors. These are errors that are not raised by Python, but are errors in the logic of the code. For example, a function that does not return the output it is supposed to return.\nConsider the example below where the goal is to create a function that substracts a number b from another number a, i.e., the function is supposed to return a - b. The programmer made a mistake and instead, the function returns a + b. There is nothing wrong with the syntax of the function, nor does Python encounter issues while running the code. However, the function does not what the programmer wants it to do.\n\ndef substract(a,b):\n    #This function substracts the number b from a\n    return a + b\n    \na = 1\nb = 2\nc = substract(a,b)\n\nprint(c) # Should be 1 - 2 = -1\n\n3\n\n\nIn the example above, it is fairly easy to conclude that the function is not behaving as it should, because almost all choices of a and b (excluding cases where a and/or b or zero) will return the wrong output.\nSometimes, however, logical errors are harder to spot as a function might still give the correct ouput for many input arguments.\nAs an example, suppose we want to create a function that can decided whether two intervals [a,b] and [c,d], with a,b,c,d \\in \\mathbb{R} and a \\leq b, c \\leq d are overlapping or not. If the first interval is [a,b] lies completelely left of the interval [c,d], i.e., if b &lt; c, then the intervals do not overlap.\n\ndef overlap(a,b,c,d):\n    if b &lt; c:\n        return print(\"No overlap!\")\n    else:\n        return print(\"There is overlap.\")\n    \na = 1\nb = 3\nc = 0.5\nd = 3.4\n\noverlap(a,b,c,d)\n\nThere is overlap.\n\n\nHowever, this function does not always give the correct output, because it does not account for the fact that the second interval [c,d] might lie completely left of the first interval [a,b], in which case there is also no overlap.\n\ndef overlap(a,b,c,d):\n    # This function check whether two intervals [a,b] and [c,d]\n    # have overlap or not.\n    if b &lt; c:\n        return print(\"No overlap!\")\n    else:\n        return print(\"There is overlap.\")\n    \na = 1\nb = 3\nc = -3\nd = -2\n\noverlap(a,b,c,d) # Gives wrong output\n\nThere is overlap.\n\n\nTo avoid logical errors, it is recommended to always test your code and functions on a diverse collection of input data.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Errors and debugging</span>"
    ]
  },
  {
    "objectID": "11-errors-and-debugging.html#exceptions",
    "href": "11-errors-and-debugging.html#exceptions",
    "title": "11  Errors and debugging",
    "section": "11.2 Exceptions",
    "text": "11.2 Exceptions\nInstead of having Python code crash due to an error, there is also the possibility to “catch” certain errors directly in a function. This allows a programmer to specify what should happen if a certain error occurs, without the whole code crashing. You can do this with a try-except construction.\nLet’s look at an example. We consider the function g that computes the square root of the first k powers of a number x and sums them up, i.e.,\n\ng(x,k) = \\sqrt{\\sum_{i=1}^k x^k} = \\sqrt{x + x^2 + x^3 + \\dots + x^k}.\n\nNote that x can be any number, but k has to be an integer for the summation to be well-defined. For example, for x = 1.3 and k = 3, we have g(1.3,3) = 1.3 + 1.3^2 + 1.3^3 = 5.187.\n\nimport math\n\n# Define the function g(x,k)\ndef g(x,k):\n    sum = 0\n    # Here we compute the sum\n    for i in range(k):\n        sum = sum + x**(i+1) # i + 1, because range() starts at 0\n    return math.sqrt(sum)\n\nx = 1.3\nk = 3\nprint(g(x,k))\n\n2.2774986278810356\n\n\nMultiple things can go wrong with trying to execute this function. For example, we might input a number k which is not an integer. This gives rise to a TypeError, because the range() function only works for integer inputs.\n\nx = 1.3\nk = 2.1\ng(x,k)\n\n\n\n\nTypeError\n\n\nOr we might input a number x for which the summation \\sum_{i=1}^k x^k is negative, in which case we cannot take the square root (recall that the square root of a negative number does not exist).\n\nx = -10\nk = 3\ng(x,k)\n\n\n\n\nValueError\n\n\nTo inform a user that tries to execute this function what goes wrong, we can use a try-except construction. The rough outline of such a construction is as follows.\n\ntry:\n    # Some code that Python should execute\nexcept SomeError:\n    # If an error of the type SomeError occurs\n    # then do ...\nexcept AnotherError:\n    # If an error of the type AnotherError\n    # occurs, then do ...\n\nA simple example, when trying to divide by zero, is given below.\n\ntry:\n    5/0\nexcept ZeroDivisionError:\n    print(\"You cannot divided by zero.\")\n\nYou cannot divided by zero.\n\n\nPython will first try to execute the code under the try statement. If this gives rise to an error (i.e., exception), then it will do as is specified under the except statement of the error that was raised.\nYou can use the try-except construction also within a function. Let us do this for the function g above.\n\nimport math\n\n# Define the function g(x,k)\ndef g(x,k):\n    try:\n        sum = 0\n        # Here we compute the sum\n        for i in range(k):\n            sum = sum + x**(i+1) # i + 1, because range() starts at 0\n        return math.sqrt(sum)\n    except TypeError:\n        return print(\"Parameter k should be an integer.\")\n    except ValueError:\n        return print(\"Cannot take square root of negative power sum.\")\n\n\nx = 1.3\nk = 2.1\ng(x,k) # Gives TypeError because k not integer.\n\nParameter k should be an integer.\n\n\n\nx = -10\nk = 3\ng(x,k) #Gives ValueError because power sum is negative.\n\nCannot take square root of negative power sum.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Errors and debugging</span>"
    ]
  },
  {
    "objectID": "11-errors-and-debugging.html#debugging",
    "href": "11-errors-and-debugging.html#debugging",
    "title": "11  Errors and debugging",
    "section": "11.3 Debugging",
    "text": "11.3 Debugging\nThe process of identifying and fixing errors (also known as bugs), is called debugging. One of the reasons errors are called bugs goes back to a computer that was built at Harvard University in 1947. At some point a moth got into the computer, which were giant at the time (the computers not the moths), and caused a piece of hardware to malfunction.\nIn general, there is no fixed recipe for how to debug a function that is not working properly, but there are many ways to get more insights in what a function is doing step-by-step, giving you the option to identify where something is going wrong. These are especially useful when you are trying to fix logical errors.\nBelow we will give some examples of what you can do to get better insights in what is going wrong in your function. This is by no means meant to be an exhaustive list.\n\n11.3.1 Use print() statements\nOne way to get some insight into what your function is doing, is to create print statements in the code. Let us have another look at the example given above.\n\nimport math\n\n# Define the function g(x,k)\ndef g(x,k):\n    sum = 0\n    # Here we compute the sum\n    for i in range(k):\n        sum = sum + x**(i+1) # i + 1, because range() starts at 0\n    return math.sqrt(sum)\n\nx = 1.3\nk = 3\nprint(g(x,k))\n\n2.2774986278810356\n\n\n\n\n\nTypeError\n\n\nPython tells us that there is a math domain error, but it does not give any explicit information about what went wrong. Given that we use the sum variable as input for the square root function, it is a good idea to keep track of how the sum argument changes throughout the execution of the function, especially what its value is when we try to input it into the square root function. We use a try-except construction to not have Python print the whole error code.\n\nimport math\n\n# Define the function g(x,k)\ndef g(x,k):\n    try:\n        sum = 0\n        # Here we compute the sum\n        for i in range(k):\n            print(\"Sum at start iteration\",i,\":\",sum) # Print here to see how sum changes\n            sum = sum + x**(i+1) # i + 1, because range() starts at 0\n        print(\"Sum after for-loop:\", sum) # Print sum at end of for-loop\n        return math.sqrt(sum)\n    except ValueError:\n        return print(\"Something goes wrong\")\n\nx = -10\nk = 3\nprint(g(x,k))\n\nSum at start iteration 0 : 0\nSum at start iteration 1 : -10\nSum at start iteration 2 : 90\nSum after for-loop: -910\nSomething goes wrong\nNone\n\n\nFrom the execution it can be seen that the sum variable is negative right before we try to use math.sqrt(sum). This is what causes the error: the value of sum is outside of the domain of the square root function (the domain is all nonnegative numbers for which the square root is well-defined).\nThe None printed at the end is the result of the final print statement print(g(x,k)) which cannot be properly executed because g(x,k) has not been computed.\n\n\n11.3.2 Use assert\nIf we already would have had some suspicion that the sum variable being negative is what is causing the error in the function g, we could have also checked this quickly by adding the command assert sum &gt;= 0 after the for-loop, instead of adding the print() statements and the try-except construction. If the assertion is not true, then Python raises an AssertionError.\n\nimport math\n\n# Define the function g(x,k)\ndef g(x,k):\n    sum = 0\n    # Here we compute the sum\n    for i in range(k):\n        sum = sum + x**(i+1) # i + 1, because range() starts at 0\n    assert sum &gt;= 0 # Check if sum is nonnegative\n    return math.sqrt(sum)\n        \nx = -10\nk = 3\nprint(g(x,k))\n\n\n\n\nAssertionError\n\n\nWe can also check the assertion with a try-except construction to avoid the error being printed.\n\nimport math\n\n# Define the function g(x,k)\ndef g(x,k):\n    try:\n        sum = 0\n        # Here we compute the sum\n        for i in range(k):\n            sum = sum + x**(i+1) # i + 1, because range() starts at 0\n        assert sum &gt;= 0 # Check if sum is nonnegative\n        return math.sqrt(sum)\n    except AssertionError:\n        return print(\"The sum is negative; cannot compute square root.\")\n\nx = -10\nk = 3\nprint(g(x,k))\n\nThe sum is negative; cannot compute square root.\nNone\n\n\n\n\n11.3.3 Use Spyder debugger\nSpyder also has the option to debug your code. What this means is that Spyder allows you to execute the code line-by-line, therefore making it easier for you to figure out at which specific line your function is running into trouble. We will next explain the very basics of debugging in Spyder.\nThe first thing you should do is set a breakpoint somewhere. What will happen is that Python will run your code until the moment it tries to execute the code on the breakpoint line. The breakpoint you set by click just right of the line number on which you want to place the breakpoint. It will then appear as a red circle next to the line number.\n\n\n\nSetting a breakpoint\n\n\nAfter you have placed the breakpoint, you should go to Debug in the toolbar of Spyder, and select Debug (Ctrl+F5).\n\n\n\nStart debug mode\n\n\nThen in the console you will see the following appearing, which indicated that you have gone into debug mode. It shows that the current execution halted at line 7, which is the line where we added the breakpoint. This is the start of the for-loop.\n\n\n\nStart debug mode\n\n\nBy pressing Ctrl+F10 (the Step option in the Debug tab), you can move one line, i.e., step, down in the execution of the code. The current line that Python is at, is denoted by the blue arrow pointing rightwards. Doing Ctrl+F10 a couple of times, we reach line 9 at which point Python will print -10. This finishes the execution of the for-loop for i = 0. If you again press Ctrl+F10, you will see that the arrow jumps back to line 7. This indicates that we again start the for-loop, but now with i = 1.\nLines that contain a print statement will have their content appear in the console. Below you can see the output -10, arising from print(sum) on line 10 in the round of the for-loop with i = 0, 90 from the round of the for-loop with i=1, and -910 from i = 2. Recall that k = 3 in this example, so the for-loop stops after i = 2 = k-1.\n\n\n\nStart debug mode\n\n\nIn general, Python will go one-by-one through all the rounds of the for-loop, for the values i = 0,\\dots,k-1. Afterwards, Python will continue with the return statement on line 10. This line-by-line execution makes it possible to identify the exact moment where your code is doing something wrong.\nWhile doing line-by-line exectution in debugging mode, you can also keep track of how variables in your code change in the variable explorer. This often also gives insights into what your code is doing.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Errors and debugging</span>"
    ]
  }
]