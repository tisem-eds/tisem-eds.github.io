[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "",
    "text": "1 About",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.1 Welcome",
    "text": "1.1 Welcome\nWelcome to the online “book” for the Programming Module of the TiSEM Minor Essential Digital Skills. We will follow the content in this book during the lectures and it is the basis of the material that will appear on the exam, so you should read through this book carefully. Because this book is new, it is likely that we will make some edits throughout the course.\nBefore we jump into coding with Python, we will start by discussing what programming is at the most basic level and motivating why we are learning how to code in Python in the first place.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-a-programming-language",
    "href": "index.html#what-is-a-programming-language",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.2 What is a Programming Language?",
    "text": "1.2 What is a Programming Language?\nWithout getting into a complicated details, a programming language is a way to communicate to a computer via written text in a way that the computer can understand you so that you can instruct it to do various operations. This is very different to how we often usually interact with a computer, which often involves pointing and clicking on different buttons and menus with your mouse.\nKnowing how to program is a very useful skill because you can automate repetitive tasks that would otherwise take you a very long time if you had to them “by hand” (i.e. by clicking things with your mouse). For example, suppose you work in a hotel in a city and you need to check how much your competitors are charging for rooms on different days so that you can adjust prices to stay competitive. Every day you have to go to all the different websites of the competing hotels and take note of the prices in an Excel sheet. With programming, what you could do instead is write code that tells the computer to automatically visit those websites every day, record the hotel room prices, and put them into a dataset for you. This is a process called web scraping and can be done with Python. This is just one example of the many ways programming languages can automate repetitive tasks.\nWhen humans speak to each other and someone makes a grammar mistake, it usually isn’t a big deal. We usually know what they mean. But if you make a “syntax error” in a programming language, it won’t understand what you mean. The computer will throw an error. What is worse still is a “semantic error” which is when the computer runs your code without an error but does something you didn’t want it to do. Therefore we need to be very careful when writing in a programming language.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#why-python",
    "href": "index.html#why-python",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.3 Why Python?",
    "text": "1.3 Why Python?\nThere are many different programming languages out there: C, C++, C#, Java, JavaScript, R, Julia, Stata, MATLAB, Fortran, Ruby, Perl, Rust, Go, Lua, Swift - the list goes on. So why should we learn Python over these other alternatives?\nThe best programming language depends on the task you want to accomplish. Are you building a website, writing computer software, creating a game, or analyzing data? While many languages could perform all of these tasks, some languages excel in some of them. In this course our goal is to learn basic programming techniques required for data science, and Python is by far the most popular programming language for this task. But it’s not only useful for that. It is also often used in web development, creating desktop applications and games, and for scientific computations. It is therefore a very versatile programming language that can complete a very wide range of tasks.\nPython is also completely free and open source and can run on all common operating systems. This means you can share your code with anyone and they will be able to run it, no matter what computer they are on or where they are in the world.\nThere is also a very large active community that creates packages to do a wide-range of operations, keeping Python up to date with the latest developments. For example, excellent community help is available at Stackoverflow, so if you Google how to do something in Python most likely that question has already been answered on Stackoverflow. Funnily enough, a key skill to develop with programming is how to formulate your question into Google to land on the right Stackoverflow page. More recently, Chat GPT has become a very useful resource for Python. Chat GPT can write excellent Python code and also explains all the steps it takes, so I encourage you to use it to help you learn. Although keep in mind it won’t be available to you in the exam, so don’t become too reliant on it!\nThese days employers are increasingly looking to hire people with programming skills. Knowing how to program in Python - one of the most commonly used languages by companies - is therefore a very valuable addition to your CV.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html",
    "href": "02-getting-started.html",
    "title": "2  Getting Started",
    "section": "",
    "text": "2.1 Installing Anaconda\nThe easiest way to install Python is by installing Anaconda. You can do this by visiting https://www.anaconda.com/download.\nYou should see this page:\nYou should click the “Skip registration” button (although feel free to register if you like). You will then see the following page:\nYou should then click on the “Download” button. Mac users will see a Mac logo instead.\nAfter downloading the file, click on it to install it. Follow the installation wizard and keep all the default options during installation.\nAfter installation you will see a number of new applications on your computer. These are:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#installing-anaconda",
    "href": "02-getting-started.html#installing-anaconda",
    "title": "2  Getting Started",
    "section": "",
    "text": "Anaconda Download Page\n\n\n\n\n\n\nAnaconda Download Page\n\n\n\n\n\n\nSpyder. This is a computer application that allows you to write Python scripts and execute them to see the output. Such an application is called an Integrated Desktop Environment (IDE). We will see how to use this below.\nJupyter Notebook. This is a web application that allows you to write a notebook (like a report) with text and Python code snippets with output. We will learn how to use this application later in this course.\nAnaconda Prompt. This is a way to manage and update packages from the command line. Packages are collections of modules that give Python more functionality, allowing you to perform different types of tasks more easily. All the packages that we will need for this course are installed by default when we install Anaconda, so we will not need to use this in this course.\nAnaconda Navigator. This is a graphical user interface for the Anaconda prompt. This essentially allows you to manage your packages without having to learn the different commands required by the Anaconda prompt. We won’t need to use this application in this course.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#spyder",
    "href": "02-getting-started.html#spyder",
    "title": "2  Getting Started",
    "section": "2.2 Spyder",
    "text": "2.2 Spyder\nOpen the Spyder program installed by Anaconda. You should see an application that looks like this:\n\n\n\nSpyder\n\n\n\n2.2.1 Python Console\nIn the bottom right pane you see a console with IPython. IPython is short for Interactive Python. We can type Python commands into this console and see the output directly. To find 1+1 in Python, we can use the command 1+1, similar to how we would do it in Excel or in the Google search engine. Let’s try this out in the console. First, click on the console to move the cursor there. Then type 1+1 and press Enter. We will see the output 2 on the next line next to a red Out [1]:\n\n\n\nIPython Console\n\n\nThe red Out [1] means this is the output from the first line of input (after the green In [1]). The second command will have input In [2] and output Out [2].\n\n\n2.2.2 Python Scripts\nTyping commands directly into the IPython console is fine if all you want to do is try out a few different simple commands. However, when working on a project you will often be executing many commands. If you were to do all of this in the interactive console it would be very easy to lose track of what you are doing. It would also be very easy to make mistakes.\nWriting your commands in Python scripts is a solution to this problem. A Python script is a text file with a .py extension where you can write all of your commands in the order you want them run. You can then get Spyder to run the entire file of commands. You can also ask it to only run part of the file. This has many advantages over typing commands into the console:\n\nIf you have run 10 commands to calculate something and then afterwards you decide to change what happened in one of the earlier commands, you would often have type all the commands again. In a script you would just need to edit the line with that command. So scripts can save you a lot of time.\nYou or anyone else can easily reproduce your work by re-running the Python script.\nBy having all the commands in a script you can more easily spot any mistakes you might have.\nIt is a way of saving your work.\n\nTherefore it’s best practice to write your code in scripts. In the exam, you will also have to supply your script with your answers.\nIn Spyder, in the left pane you see a file open called temp.py. This is an example Python script. We can ignore what is written in the first 6 lines of the script. We can add our 1 + 1 command to the bottom of the script like this and save it:\n\n\n\nPython Script\n\n\nIn the Toolbar there are several ways to run this command from the script. For example, you can run the entire file, or run only the current line or selected area. If the cursor is on the line with 1 + 1 and we press the “Run selection or current line” button, then we will see the command and output appear in the IPython console, just like how we typed it there before. Using the script, however, we have saved and documented our work.\nIf you try run the entire file, you will see runfile('...') in the IPython console with the ... being the path to the Python script you are running. However, you don’t see a 2 in the output. This is because when running an entire file, Python does not show the output of each line being run. To see the output of any command we need to put it inside the print() function. We can change our line to print(1 + 1) to see the output when running the entire file:\n\n\n\nUsing the print() function\n\n\nWhen you run the entire file you should now see a 2 below the runfile('...') command.\nWe now know how to write and run Python scripts! In the next chapter we will learn more Python commands.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#code-snippets-in-this-book",
    "href": "02-getting-started.html#code-snippets-in-this-book",
    "title": "2  Getting Started",
    "section": "2.3 Code Snippets in This Book",
    "text": "2.3 Code Snippets in This Book\nIn this book, we won’t always show screenshots like we did above. Instead we will show code snippets in boxes like this:\n\n1 + 1\n\n2\n\n\nThe part that is code will be in color and there will be a small clipboard icon on the right which you can use to copy the code to paste into your script to be able to experiment with it yourself. The output from the code will always be in a separate gray box below it (without a clipboard icon).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html",
    "href": "03-python-as-a-calculator.html",
    "title": "3  Python as a Calculator",
    "section": "",
    "text": "3.1 Addition, Subtraction, Multiplication and Division\nWe start with the most basic operations. Addition, subtraction, multiplication and division are given by the standard +, -, * and / operators that you would use in other programs like Excel. For example:\nAddition:\n2 + 3\n\n5\nSubtraction:\n5 - 3\n\n2\nMultiplication:\n2 * 3\n\n6\nDivision:\n3 / 2\n\n1.5\nIt is also possible to do multiple operations at the same time using parentheses. For example, suppose we wanted to calculate: \n\\frac{2+4}{4\\times 2} = \\frac{6}{8} = 0.75\n We can calculate this in Python as follows:\n(2 + 4) / (4 * 2)\n\n0.75",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#troubleshooting-escaping-in-python",
    "href": "03-python-as-a-calculator.html#troubleshooting-escaping-in-python",
    "title": "3  Python as a Calculator",
    "section": "3.2 Troubleshooting: “Escaping” in Python",
    "text": "3.2 Troubleshooting: “Escaping” in Python\nSuppose by accident you left out the closing parentheses above. You typed (2 + 4) / (4 * 2 and Enter. You don’t see the output but instead see\nIn [1]: (2 + 4) / (4 * 2\n   ...:\nPython did not run the command, but it also did not give an error. What happened is that because there was no closing parenthesis Enter moved to a new line instead of executing the command. That’s why we see the ...:. To “Escape” this situation, you just need to press the Ctrl+C button. In general, if anything strange happens in Python and you get stuck, you can always press Ctrl+C in the console to escape the current command.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#exponentiation-taking-powers-of-numbers",
    "href": "03-python-as-a-calculator.html#exponentiation-taking-powers-of-numbers",
    "title": "3  Python as a Calculator",
    "section": "3.3 Exponentiation (Taking Powers of Numbers)",
    "text": "3.3 Exponentiation (Taking Powers of Numbers)\nx^n multiplies x by itself n times. For example, 2^3=2\\times 2\\times 2 = 8. In Python we use ** to do this:\n\n2 ** 3\n\n8\n\n\nBe very careful not to use ^ for exponentiation. This actually does a very different thing that we won’t have any use for in this course.1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#absolute-value",
    "href": "03-python-as-a-calculator.html#absolute-value",
    "title": "3  Python as a Calculator",
    "section": "3.4 Absolute value",
    "text": "3.4 Absolute value\nTaking the absolute value turns a negative number into the same number without a minus sign. It has no effect on positive numbers.\nIn mathematical notation we write |x| for the absolute value of x. The formal definition is:\n\n|x| = \\begin{cases} x & \\text{ if } x \\geq 0 \\\\ -x & \\text{ otherwise}\n\\end{cases}\n\nHere are some examples:\n\n|-2|=2\n|3|=3.\n\nThis is what the function looks like when we plot it for different x:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-10, 10, 400)\n\n# Define the absolute value function\ny = np.abs(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = |x|')\n\n# Add labels and title\nplt.title('Absolute Value Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nWe’ll learn how to make plots like this later in this course, but if you want to see the code generating it you can click on the button “Show code generating the plot below”.\nIn Python we can calculate absolute values with:\n\nabs(-2)\n\n2\n\n\n\nabs(3)\n\n3\n\n\nTaking the absolute value in Python involves using what is called a function. Functions are used by calling their names and giving the arguments to the function in parentheses. When we do abs(-2), abs is the name of the function and -2 is the argument.\nIn many ways the functions in Python work a lot like the functions in Excel, just they might have different names or be used a bit differently. For example, in Excel you write =ABS(-2) to take the absolute value of -2. The argument is the same, and the function name only differs in that in Excel you need to use capital letters whereas in Python you use lowercase letters (in addition, Excel requires you to put an = before the function name).\nWhen using functions it is helpful to read their help pages. You can look at this by typing help(abs) in the Console and pressing Enter. We then see:\nHelp on built-in function abs in module builtins:\n\nabs(x, /)\n    Return the absolute value of the argument.\nThis tells us that abs() takes a single argument and returns the absolute value.2\nWe will be using many different functions and it’s a good habit of to look at their help pages. The help pages will be available to you in the Exam.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#square-roots",
    "href": "03-python-as-a-calculator.html#square-roots",
    "title": "3  Python as a Calculator",
    "section": "3.5 Square Roots",
    "text": "3.5 Square Roots\nThe square root of a number x is the y that solves y^2=x. For example, if x=4, both y=-2 and y=2 solve this. The principal square root is the positive y from this.\nHere is what the square root function looks like for different x:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range (positive values because np.sqrt() not defined for negative\n# values)\nx = np.linspace(0, 10, 400)\n\n# Define the square root function\ny = np.sqrt(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = √x')\n\n# Add labels and title\nplt.title('Square Root Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nThe principal square root a number is equal to the number exponentiated by \\frac{1}{2}:\n\n\\sqrt{x} = x^\\frac{1}{2}\n\n\n9 ** (0.5)\n\n3.0\n\n\nWe can follow a very similar approach to above to get the cubed root of a number, such as: \\sqrt[3]{8}=8^\\frac{1}{3}=2:\nIn Python:\n\n8 ** (1/3)\n\n2.0\n\n\nPython also has a square root function, but it is not built in. We need to load this function by loading the module math. A module is a collection of additional functions and other objects that we can load in our Python script. The module math contains many mathematical functions, including the sqrt() function.\nTo load the math module, we need to include import math in our script before executing any of its functions. To run the sqrt() function from the math module, we need to type math.sqrt(). This “dot” notation means we use the sqrt() function within the math module.\nTo get \\sqrt{9} then we can do:\n\nimport math\nmath.sqrt(9)\n\n3.0\n\n\nTo view the help page math.sqrt(), we can use help(math.sqrt).\nIf you only want to use the sqrt() function from the math module, you could alternatively import the function the following way:\n\nfrom math import sqrt\nsqrt(9)\n\n3.0\n\n\nThis way you don’t need to type math.sqrt() every time you want to take the square root, and only need to type sqrt(). However, it is generally preferred practice to import the math module using import math and use the function with math.sqrt(). This makes the code clearer and easier to understand.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#exponentials",
    "href": "03-python-as-a-calculator.html#exponentials",
    "title": "3  Python as a Calculator",
    "section": "3.6 Exponentials",
    "text": "3.6 Exponentials\nA very important function in mathematics and statistics is the exponential function. The definition of \\exp\\left(x\\right), or e^x, is given by: \ne^x = \\underset{n\\rightarrow \\infty}{\\lim} \\left(1 + \\frac{x}{n}\\right)^n\n\nNote: you don’t need to know or remember this definition for the exam. You only need to know how to calculate the exponential function in Python.\nThis is what the function looks like:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-2, 2, 400)\n\n# Define the exponential function\ny = np.exp(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = e^x')\n\n# Add labels and title\nplt.title('Exponential Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nIn Python we can use the exp() function from the math module to calculate the exponential of any number:\n\nmath.exp(1)\n\n2.718281828459045",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#logarithms",
    "href": "03-python-as-a-calculator.html#logarithms",
    "title": "3  Python as a Calculator",
    "section": "3.7 Logarithms",
    "text": "3.7 Logarithms\nAnother common mathematical function is the logarithm, which is like the reverse of exponentiation.\nThe log of a number x to a base b, denoted \\log_b\\left(x\\right), is the number of times we need to multiply b by itself to get x. For example, \\log_{10}\\left(100\\right) = 2, because 10\\times 10=100. We need to multiply the base b=10 by itself twice to get to x=100.\nA special logarithm is the natural logarithm, \\log_e(x), which is the logarithm to the base \\exp(1)=e^1\\approx 2.7183. This is also written as \\ln(x).\nThis is what the function looks like:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range (positive values only, since ln(x) is undefined for non-positive x)\nx = np.linspace(0.1, 10, 400)  # Start from 0.1 to avoid log(0), which is undefined\n\n# Define the natural logarithm function\ny = np.log(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\n\nplt.plot(x, y, label='y = ln(x)')\n\n# Add labels and title\nplt.title('Natural Logarithm Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nIn Python we use the log() function from the math module to calculate the natural logarithm:\n\nimport math\nmath.log(1)\n\n0.0\n\n\nWhat if we want to calculate the logarithm to a base other than e? If we look at the help page for log() using help(math.log), we see:\nHelp on built-in function log in module math:\n\nlog(...)\n    log(x, [base=math.e])\n    Return the logarithm of x to the given base.\n    \n    If the base not specified, returns the natural logarithm (base e) of x.\nWe can see that the log() function can take 2 arguments:\n\nx: the number we want to take the log of.\nbase: the base with respect to which the logarithms are computed. The default is math.e which equals the value of e\\approx 2.718. Because this argument is contained in a square bracket, it means it is an optional argument. If we don’t provide it it will use the default.\n\nThis is the first time that we have seen a function with more than one argument. Earlier when we used the math.log() to calculate the natural logarithm we only used one argument because we used the default setting for the base. But when we want to use a base other than e, we need to specify it.\nTo calculate \\log_{10}\\left(100\\right) in Python is then done as follows:\n\nimport math\nmath.log(100, 10)\n\n2.0\n\n\nWe write both arguments into the math.log() function, separated by commas.\nThe math module contains many more mathematical functions. To see all the functions available in the math module, we can use the command dir(math). You will see many familiar mathematical functions, such as the trigonometric functions sin(), cos(), and tan().",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#integer-division-and-the-modulus-operator",
    "href": "03-python-as-a-calculator.html#integer-division-and-the-modulus-operator",
    "title": "3  Python as a Calculator",
    "section": "3.8 Integer Division and The Modulus Operator",
    "text": "3.8 Integer Division and The Modulus Operator\nWhen we divide 7 by 3 we get 2\\frac{1}{3}. We could alternatively say that “7 divided by 3 equals 2 with remainder 1”. When programming it is often useful to get these numbers. The tutorial exercises will have several examples of this!\nWe can perform “integer division” with the // operator. This always returns the fraction rounded down to the nearest whole number:\n\n7 // 3\n\n2\n\n\nTo get the remainder we use the modulus operator %:\n\n7 % 3\n\n1\n\n\nTogether then 7/3 is 2 with remainder 1.\nOne thing to note is that integer division with negative numbers doesn’t round to the integer closest to zero, but always down. So:\n\n-7 // 3\n\n-3\n\n\nand:\n\n7 // -3\n\n-3\n\n\nboth give -3 and not -2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#footnotes",
    "href": "03-python-as-a-calculator.html#footnotes",
    "title": "3  Python as a Calculator",
    "section": "",
    "text": "For example, 2^3 converts 2 and 3 to binary (10 and 11 respectively) and then does a “bitwise excluse OR operation” on these (which results in 01) and converts it back to in integer (which is 1). So 2 ** 3 gives 8 but 2^3 gives 1.↩︎\nThe forward slash in abs(x, /) marks the end of the positional-only arguments in the function. The abs() function takes only one argument, so you can think of this slash as meaning there is only one argument to abs(). Some functions like the math.log() function that we will see below have two arguments (the number we are taking the log of and the base) and the position (order) of the arguments we provide matter. Other functions, such as the print() function we have already encountered, allow you to provide arguments by a keyword (see help(print) for these).↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html",
    "href": "04-data-types-part1.html",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "4.1 Variables\nIn Python we can assign single values to variables and then work with and manipulate those variables.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#variables",
    "href": "04-data-types-part1.html#variables",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "4.1.1 Assigning Values to Variables\nAssigning a single value to a variable is very straightforward. We put the name we want to give to the variable on the left, then use the = symbol as the assignment operator, and put the value to the right of the =. The = operator binds a value (on the right-hand size of =) to a name (on the left-hand side of =).\nTo see this at work, let’s set x=2 and y=3 and calculate x+y:\n\nx = 2\ny = 3\nx + y\n\n5\n\n\nIn Spyder there is a “Variable Explorer” in the top-right pane to see the variables we have created:\n\n\n\nVariable Explorer in Spyder\n\n\nWe can see that x has a value 2 and y has a value 3.\nWhen we assign x=2, in our code, the value is not fixed forever. We can assign a new value to x. For example, we can assign the number 6 to x instead:\n\nx = 6\nx + y\n\n9\n\n\nFinally, you cannot set x=2 with the command 2 = x. That will result in an error. The name must be on the left of = and the value must be on the right of =.\n\n\n4.1.2 Rules for Naming Variables\nVariable names can be multiple letters long and can contain underscores (_). Underscores are useful because variable names cannot contain spaces and so we can use underscores to represent spaces. Variable names can contain numbers but they cannot start with one. For example x1 and x_1 are legal names in Python, but 1x is not. There are 35 keywords that are reserved and cannot be used as variable names because they are fundamental to the language. For example, we cannot assign a value to the name True, because that is a keyword. Below is the list of all keywords.1 We will learn what many of these keywords are later in this course and how to use them.\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#common-data-types-for-single-values",
    "href": "04-data-types-part1.html#common-data-types-for-single-values",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.2 Common Data Types for Single Values",
    "text": "4.2 Common Data Types for Single Values\n\n4.2.1 Integers\nYou may have noticed that the “Variable Explorer” in Spyder had a “Type” column. For x and y this was int which means “integer”. Integers are whole numbers that can also be negative. We can also check the type of a variable using the type() function:\n\ntype(x)\n\nint\n\n\n\n\n4.2.2 Floating-Point Numbers\nNumbers that are not whole numbers have the type float, which stands for floating-point number:\n\ntype(1.2345)\n\nfloat\n\n\nAll the operations we learned about in Chapter 3 also work with floating-point numbers. For example:\n\n1.2 * 3\n\n3.5999999999999996\n\n\nYou will notice that we don’t get 3.6 like we expected, but instead something very very close but slightly different to 3.6. This is because of how floating-point numbers are represented internally by the computer. The number is split into an integer with a fixed degree of precision and an exponential scaler. For example 1.2 is the same as 12\\times 10e^{-1}, so the computer needs two integers: 12 and -1 (the exponent) to represent 1.2. Because this process involves some approximations when we perform arithmetic operations on them we can lose some accuracy. However, for most purposes 3.5999999999999996 is close enough to 3.6.\n\n\n4.2.3 Strings\nPython can also work with text in the form of strings. Text in Python needs to be wrapped in quotes. These can be either single quotes (') or double quotes (\"), provided they match.\n\ntype('Hello world')\n\nstr\n\n\n\ntype(\"This is a string\")\n\nstr\n\n\nThis str means it is a “string” which is a sequence of individual characters.\nOne thing to be careful with strings is that if you have a string that contains double quotes you have to wrap it in single quotes and vice versa:\n\nquote = 'Descartes said \"I think, therefore I am\" in 1637'\napostrophe = \"Don't wrap this with single quotes!\"\n\nIf you find yourself in the unusual situation with a string with both single and double quotes, you can wrap them in triple single quotes ('''):\n\nquote_with_apostrophe = '''As they say, \"Don't judge a book by its cover\"'''\n\nAnother thing to be careful with strings is that numbers surrounded by quotes are strings and not numbers:\n\ntype('1.2')\n\nstr\n\n\nWe can use some of the operators for numbers on strings, but they do very different things. The + operator combines strings:\n\na = 'Hello, '\nb = 'world'\na + b\n\n'Hello, world'\n\n\nAnd the * operator repeats strings:\n\na = 'Hello! '\na * 3\n\n'Hello! Hello! Hello! '\n\n\n\n\n4.2.4 Boolean Values\nIn programming it is often useful to work with variables that are either true or false. Therefore Python has a special data type for this called the Boolean data type. This is named after George Boole who was a mathematics professor in Ireland in the 1800s.\nThe Boolean values are either True or False. The words must be capitalized and spelled exactly this way. These are two of Python’s keywords.\n\na = True\nb = False\ntype(a)\n\nbool\n\n\nTrue and False are 2 of the keywords that cannot assign values to. Try 2 = True yourself and see the error that you get.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#logical-and-comparison-operators",
    "href": "04-data-types-part1.html#logical-and-comparison-operators",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.3 Logical and Comparison Operators",
    "text": "4.3 Logical and Comparison Operators\n\n4.3.1 Logical Operators\nBoolean values have their own operations: and, or and not. These are called logical operators. These work as follows:\n\na and b is True if both a and b are True. Otherwise it is False (if either or both of a or b are False). Here are all the possible combinations:\n\n\n\n\na\nb\na and b\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nFalse\nFalse\nFalse\n\n\n\n\na or b is True if either a or b (or both) are True. Otherwise it is False (if both a and b are False). Here are all the possible combinations:\n\n\n\n\na\nb\na or b\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\n\n\n\n\nnot a is True if a is False and is False if a is True. The not operator flips the value. Here are all the possible combinations:\n\n\n\n\na\nnot a\n\n\n\n\nTrue\nFalse\n\n\nFalse\nTrue\n\n\n\nLet’s try them out on two specific values a and b, where a is True and b is False:\n\na = True\nb = False\na and b\n\nFalse\n\n\nThis is False because we need both a and b to be True.\n\na or b\n\nTrue\n\n\nThis is True because at least one of a or b is True.\n\nnot a\n\nFalse\n\n\nThis is False because a is True. It flips the value.\n\n\n4.3.2 Comparison Operators\nPython has operators to check if one number is equal to, not equal to, greater than (or equal to), or less than (or equal to) another number. It checks the (in)equality and returns True or False depending on the result.\nTo check if a=b, we use the == operator:\n\na = 3\nb = 2\na == b\n\nFalse\n\n\na\\neq b, so we get False. Be careful to use two equal symbols and not one. If we did a = b, it would just reassign to a the value of b (2):\n\na = 3\nb = 2\na = b\na\n\n2\n\n\nTo check if a\\neq b, we use the != operator (which is supposed to look like the \\neq symbol):\n\na = 3\nb = 2\na != b\n\nTrue\n\n\nThis is True, because a and b are not equal.\nTo see if a&gt;b, we use &gt; and to see if a\\geq b we use a &gt;= b:\n\na = 3\nb = 2\na &gt;= b\n\nTrue\n\n\nWe get True because a\\geq b.\nTo see if a&lt;b, we use &lt; and to see if a\\leq b we use a &lt;= b:\n\na = 3\nb = 2\na &lt;= b\n\nFalse\n\n\nWe get False because a\\ngeq b.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#type-conversion",
    "href": "04-data-types-part1.html#type-conversion",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.4 Type Conversion",
    "text": "4.4 Type Conversion\nWe can sometimes convert objects between int, float, str and bool. Sometimes this conversion is not so intuitive so you need to be careful and know how it works.\nIf we assign x=1, it will automatically be made an int:\n\nx = 1\ntype(x)\n\nint\n\n\nBut we can convert x to a float using the float() function. Let’s assign y to be x as a float:\n\ny = float(x)\ntype(y)\n\nfloat\n\n\n\ny\n\n1.0\n\n\nWe can see that y is not 1 but 1.0. The .0 helps us recognize that this is a float.\nWe can also convert the integer to a string:\n\nz = str(x)\ntype(z)\n\nstr\n\n\n\nz\n\n'1'\n\n\nThe quotes around the 1 helps us recognize that this is a string.\nFinally we can also convert from a float to a string:\n\nstr(y)\n\n'1.0'\n\n\nIf you have an integer stored as a string, we can convert it back to an integer:\n\nint('1')\n\n1\n\n\nOr you can convert it to a float:\n\nfloat('1')\n\n1.0\n\n\nAnd if a float is stored as a string, we can convert it back to a float:\n\nfloat('1.5')\n\n1.5\n\n\nHowever, it is not possible to convert '1.5' to an integer - that will return an error. Similarly you cannot convert strings with characters to integers or floats.\nWe can also convert floats to integers:\n\nint(1.0)\n\n1\n\n\nIf we try to convert a float that isn’t a whole number to an integer it will always take the closest integer to zero. For positive numbers this means it always rounds down:\n\nint(1.1)\n\n1\n\n\n\nint(1.9)\n\n1\n\n\nAnd for negative numbers it always rounds up:\n\nint(-2.1)\n\n-2\n\n\n\nint(-2.9)\n\n-2\n\n\nThe Boolean values True and False can be converted to integers, floats and stringers. True becomes 1, 1.0 and 'True' and False becomes 0, 0.0 and 'False', respectively. We can also convert integers 1 and 0 back to Boolean:\n\nbool(1)\n\nTrue\n\n\n\nbool(0)\n\nFalse\n\n\nHowever, if we try convert strings to Boolean we get some unintuitive results. For example:\n\nbool('0')\n\nTrue\n\n\n\nbool('False')\n\nTrue\n\n\nNon-empty strings always return True. Only empty strings return False:\n\nbool('')\n\nFalse\n\n\nThis is an example of when a programming language does something unintuitive. Therefore when writing a longer program you really need to be sure what each line is doing, otherwise your program will do something unexpected.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#footnotes",
    "href": "04-data-types-part1.html#footnotes",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "The keyword module contains functions for testing if a string is a keyword. The command keyword.kwlist returns the full list of keywords.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html",
    "href": "05-data-types-part2.html",
    "title": "5  Data Types for Multiple Values",
    "section": "",
    "text": "5.1 Introduction\nIn Chapter 4 we learned about the int, float, str and bool data types, which all had single values. But we often have to deal with many values. For example, suppose you wanted to analyze the past daily sales of a company in recent years. It would not be very convenient to assign each of the hundreds of values of sales to different variables and work with them. Python has other data types available to deal with multiple values: lists, tuples, dictionaries, sets and frozen sets. These will be the focus of this chapter.\nIn later chapters we will also see that there are Python modules that have other data types. In this chapter we will focus on the data types that come built in.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#lists",
    "href": "05-data-types-part2.html#lists",
    "title": "5  Data Types for Multiple Values",
    "section": "5.2 Lists",
    "text": "5.2 Lists\nA very common way to store a sequence of values (which could be integers, floats, strings or Booleans), is in a list. You can create a list by putting the values in between square brackets, separated by commas:\n\na = [2, 4, 6]\na\n\n[2, 4, 6]\n\n\nLists can also be composed of floats, Booleans, or strings, or even a combination of them:\n\na = [1, 1.1, True, 'hello']\n\nLists can even have other lists as elements:\n\na = [1, 2, [3, 4]]\n\nAlthough we see 4 numbers, this list actually has only 3 elements:\n\nlen(a)\n\n3\n\n\nwhere the len() function returns the length of its argument. The [3, 4] is actually considered one element and is itself a list. This kind of a list is called a nested list.\n\n5.2.1 List Operations\nIf we use the + operator on lists it just creates a longer list with one appended to the other:\n\na = [2, 4, 6]\nb = [8, 10]\na + b\n\n[2, 4, 6, 8, 10]\n\n\nIf we use the * operator it repeats the list:\n\na = [2, 4, 6]\na * 3 \n\n[2, 4, 6, 2, 4, 6, 2, 4, 6]\n\n\nWe cannot use the - and / operators on lists. In these ways lists behave like strings.\n\n\n5.2.2 List Indexing\nLists are ordered so the order in which we place the elements matters. To extract a particular value from a list based on its position in the list we can use a method called indexing. If we want the first element of the list we can extract it with a[0]:\n\na[0]\n\n2\n\n\nThe 0 here is the index. It means to take element 0 from the list. In Python and several other programming languages (like C and C++), counting starts at 0 instead of 1. So element 0 is actually the 1st element. This is something that might take some getting used to, so be careful when using indexing.\nEven though the list has 3 elements, the last element is extracted with a[2]:\n\na[2]\n\n6\n\n\nIf you try to do a[3] you get an IndexError saying the list index is out of range.\nWe can also use negative indexing to extract elements from the end of a list. For example, to get the last element of a list a we can use a[-1], to get the 2nd-last element we can use a[2], and so on:\n\na = [1, 2, 3, 4, 5, 6]\na[-1]\n\n6\n\n\n\na[-2]\n\n5\n\n\nIndexing like this also works for strings, and many other objects with multiple values. For example, to get the first character in a string we can get the value at index 0:\n\na = 'hello'\na[0]\n\n'h'\n\n\nWe can also use indexing to change values in a list:\n\na = [2, 4, 6]\na[0] = 8\na\n\n[8, 4, 6]\n\n\nBecause lists have this property, we say they are mutable. This is unlike strings which are immutable. You can’t change a character in a string using indexing (try it out with the commands a = 'hello' and a[0] = g).\n\n\n5.2.3 List Slicing\nTo get all elements starting from 1 up to but not including index 3 (the 2nd and 3rd element) we can do:\n\na = [1, 2, 3, 4, 5]\na[1:3]\n\n[2, 3]\n\n\nTo get all elements starting from index 2 (the 3rd element onwards) we can do:\n\na[2:]\n\n[3, 4, 5]\n\n\nTo get all elements up to but not including index 2 (the 1st and 2nd element) we can do:\n\na[:2]\n\n[1, 2]\n\n\nFinally, the following just returns the original list:\n\na[:]\n\n[1, 2, 3, 4, 5]\n\n\n\n\n5.2.4 List Methods\nLists, like many objects in Python, have methods. A method in Python is like a function but instead of using the object as an argument to the function, we apply the function to the object. We’ll see what we mean by this with an example. Suppose we wanted to add another number to our list at the end, like the number 8. Instead of recreating the entire list with a = [2, 4, 6, 8], we can append 8 to the end of the list using the append() method. Methods are invoked by placing them after the object separated with a . like this:\n\na = [2, 4, 6]\na.append(8)\na\n\n[2, 4, 6, 8]\n\n\nNotice that we didn’t need to assign the output of append() to an object with =. It altered a in place. This is what the method does.\nTo remove an element from a list we can use the pop() method. For example, to remove the 2nd element (element with index 1), we can do:\n\na = [2, 4, 6]\na.pop(1)\na\n\n[2, 6]\n\n\nAnother list method is reverse() which reverses the ordering of the list:\n\na = [2, 6, 4]\na.reverse()\na\n\n[4, 6, 2]\n\n\nTo sort a list ascending we can use sort():\n\na = [1, 3, 2]\na.sort()\na\n\n[1, 2, 3]\n\n\nTo see the full list of methods available for your list, you can use the command dir(a).\nUsing the sort() method changes our original list. Sometimes we want to see the sorted version of a list but then go back to the original ordering. In this case you shouldn’t use the sort() method on the list but use the sorted() function to create a sorted version of the list. The sorted() function returns its input sorted:\n\na = [1, 3, 2]\nb = sorted(a)\nb\n\n[1, 2, 3]\n\n\n\n\n5.2.5 Iterating over Items in a List\nA useful feature of a list is that we can iterate over each element, performing the same operation or set of operations on each element one by one. For example, suppose we wanted to see what the square of each element in the list was. We can use what is called a for loop to do this. Here is how to code it:\n\na = [2, 4, 6, 8]\nfor i in a:\n    print(i ** 2)\n\n4\n16\n36\n64\n\n\nIn words, what is happening is “for all i in the list a, print i^2”. We use i as a sort of temporary variable for each element in a. The next line then prints i ** 2 which squares i. You will notice that the print() command is indented with 4 spaces. This is to tell Python that this command is part of the loop. When there is code under the for loop that is not indented, Python interprets this as not being part of the loop.\nTo understand this, compare the following two snippets, which are almost the same except the first print('hello') is indented and the second is not:\n\na = [2, 4, 6, 8]\nfor i in a:\n    print(i ** 2)\n    print('hello')\n\n4\nhello\n16\nhello\n36\nhello\n64\nhello\n\n\n\na = [2, 4, 6]\nfor i in a:\n    print(i ** 2)\nprint('hello')\n\n4\n16\n36\nhello\n\n\nThe first code prints 'hello' 3 times, and the second only once, even though the code looks almost the same except for the indentations. This is because in the first case, the indentation tells Python that that print() call is part of the loop. In each iteration of the loop, we have to print the square of i and print hello. The loop iterates 3 times, so we see 'hello' 3 times.\nIn the second case, the lack of indentation tells Python that the print('hello') is not in the loop. Python first finishes the loop (squaring each element of a and printing it). It only then gets to the next part of the code and prints 'hello'.\nTherefore it is very important to be careful with indentation with Python. You should indent with 4 spaces (not tabs) for content in a loop.\nAnother thing to note here is that a for loop is a situation where the code is no longer running line-by-line from top to bottom. The code goes to the end of the loop and if there are iterations remaining to be done it goes back to the start of the loop. Only when it has completed all the iterations does it go to the next line after the loop.\n\n\n5.2.6 List Comprehensions\nSuppose we wanted to save the square of each element of a into a new list called b. One way to do that would be to create an empty list called b with b = []. This is a list with no elements. Then we could use the for loop to append the values to b, like this:\n\na = [2, 4, 6]\nb = []\nfor i in a:\n  b.append(i ** 2)\nb\n\n[4, 16, 36]\n\n\nThis works just fine, but the code is a bit “clunky”. Moreover, if your list is very very large it would run very slowly. A cleaner and faster way to do this kind of operation is by using list comprehensions.\n\na = [2, 4, 6]\nb = [i ** 2 for i in a]\nb\n\n[4, 16, 36]\n\n\nThis is a very neat and compact way to create the new list. It also reads similar to how we would describe what is happening: “make a list which is i^2 for all elements i in the list a”.\n\n\n5.2.7 List Membership\nTo see if an element is contained somewhere in a list, we can use the in operator:\n\na = [2, 4, 6]\n4 in a\n\nTrue\n\n\n\n5 in a\n\nFalse\n\n\n4 is in a so we get True, but 5 is not so we get False.\n\n\n5.2.8 Copying Lists\nOne thing to note about lists, which may be unexpected, is that if we create a list a and set b = a, we are actually telling Python that a and b refer to the same object, not just that they have the same values. This has the consequence that if we change a that b will also change. For example:\n\na = [2, 4, 6]\nb = a\na[0] = 8\nb\n\n[8, 4, 6]\n\n\nWe set b = a but otherwise perform no operations on b. We change the first element of a (element 0) to 8, and the first element of b changes to 8 as well!\nOften when we are programming we don’t want this to happen. We often want to copy a list to a new one to perform some operations and leave the original list unchanged. What we can do instead is set b equal to a[:] instead of a. This way b won’t change when a changes:\n\na = [2, 4, 6]\nb = a[:]\na[0] = 8\nb\n\n[2, 4, 6]\n\n\nAnother way is to use the copy() method:\n\na = [2, 4, 6]\nb = a.copy()\na[0] = 8\nb\n\n[2, 4, 6]\n\n\nBecause there are two different ways of copying objects with different consequences, we have two different terms for them:\n\nDeep copy: This copies a to b and recursively copies all of its elements, resulting in a completely independent object.\nShallow copy: This copies a to b but does not recursively copy its elements. Instead it only copies the references to the elements in a (like the address for where in the computer’s memory those elements are stored). This means that changes to elements of a will affect the elements of b.\n\nThe b = a example is a shallow copy and the b = a[:] example is like a deep copy. However, it is not a full deep copy. Using a[:] or a.copy() only works if our list is not nested. This method only takes a deep copy of the outermost list. If we copy with a[:] or a.copy() to b with a nested listed and then change an element inside one of the nested lists, then the copied object will change as well. For example:\n\na = [2, 4, [6, 8]]\nb = a[:]\na[2][1] = 5\nb\n\n[2, 4, [6, 5]]\n\n\nb changes as well! The same happens with the copy() method:\n\na = [2, 4, [6, 8]]\nb = a.copy()\na[2][1] = 5\nb\n\n[2, 4, [6, 5]]\n\n\nTo make a full deep copy which recursively copies the entire object, we can use the deepcopy() function from the copy module:\n\nimport copy\na = [2, 4, [6, 8]]\nb = copy.deepcopy(a)\na[2][1] = 5\nb\n\n[2, 4, [6, 8]]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#tuples",
    "href": "05-data-types-part2.html#tuples",
    "title": "5  Data Types for Multiple Values",
    "section": "5.3 Tuples",
    "text": "5.3 Tuples\nA tuple is another data type that is quite similar to a list. One important difference, however, is that they are immutable. We cannot change individual values of a tuple after they are created, and we cannot append values to a tuple.\nWe can create a tuple in Python using parentheses instead of square brackets:\n\na = (2, 4, 6)\n\nIndexing and many other operations that work for lists also work with tuples. We index them the same way as lists (using square brackets like a[0]) and we can iterate over the items with for loops in the same way. However the list of methods for tuples is much shorter. We cannot append or pop values because the tuples are immutable.\n\n5.3.1 Tuple Assignment\nOne useful thing we can do with tuples is tuple assignment. Suppose we have a list x = ['a', 'b', 'c'] and we wanted to create 3 objects from this: x_0 = 'a', x_1 = 'b' and x_2 = 'c'. One way to do this is:\n\nx = ['a', 'b', 'c']\nx_0 = x[0]\nx_1 = x[1]\nx_2 = x[2]\n\nBut a much more elegant way to do this is using tuple assignment:\n\nx = ['a', 'b', 'c']\n(x_0, x_1, x_2) = x\n\nThis assigns 'a' to x_0, 'b' to x_1 and 'c' to x_2 all in one line.\nThis is especially useful if you have a function that returns multiple objects and we want to assign each output to a different variable. For example, the function divmod(a, b) gives the quotient and remainder from dividing a with b. It essentially calculates a // b and a % b and returns a tuple with both objects:\n\ndivmod(7, 3)\n\n(2, 1)\n\n\nThis means 7 divided by 3 is 2 with remainder 1. We can use tuple assignment with the output to get:\n\n(quotient, remainder) = divmod(7, 3)\nquotient\n\n2\n\n\n\nremainder\n\n1",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#dictionaries",
    "href": "05-data-types-part2.html#dictionaries",
    "title": "5  Data Types for Multiple Values",
    "section": "5.4 Dictionaries",
    "text": "5.4 Dictionaries\nAnother common built-in data type is a dictionary. A dictionary maps keys to values, where the keys can be an immutable data type (usually an integer or string) and the values can be any type, for example, single values, lists, or tuples. For example, a company might have supplier IDs for its suppliers and a dictionary mapping those IDs to the actual company name. In this case, the company IDs are the keys and the company names are the values.\nWe could create a simple dictionary like this as follows:\n\nsuppliers = {100001 : 'ABC Ltd.', 100002 : 'EFG Ltd.'}\n\nDictionaries are created within curly brackets with the structure {key1 : value1, key2 : value2, key3 : value3}.\nTo find a company name using the company ID we provide the key in the place we would supply an index for a list or tuple:\n\nsuppliers[100001]\n\n'ABC Ltd.'\n\n\nDictionaries are unordered, so we cannot do suppliers[0] to find the first supplier. There is no first value in a dictionary.\nWe can also add new keys and values to the dictionary:\n\nsuppliers[100003] = 'HIJ Ltd.'\nsuppliers\n\n{100001: 'ABC Ltd.', 100002: 'EFG Ltd.', 100003: 'HIJ Ltd.'}\n\n\nWe can also modify values:\n\nsuppliers[100003] = 'KLM Ltd.'\nsuppliers\n\n{100001: 'ABC Ltd.', 100002: 'EFG Ltd.', 100003: 'KLM Ltd.'}\n\n\nTo get all the keys in a dictionary we can use the keys() method:\n\nsuppliers.keys()\n\ndict_keys([100001, 100002, 100003])\n\n\nAnd to get all the values in a dictionary we can use the values() method:\n\nsuppliers.values()\n\ndict_values(['ABC Ltd.', 'EFG Ltd.', 'KLM Ltd.'])\n\n\nUsing a for loop with a dictionary implicitly iterates over the keys. So we can loop over the keys of a dictionary in the following way:\n\nfor key in suppliers:\n    print('Supplier with ID ' + str(key) + ' is ' + suppliers[key])\n\nSupplier with ID 100001 is ABC Ltd.\nSupplier with ID 100002 is EFG Ltd.\nSupplier with ID 100003 is KLM Ltd.\n\n\nFinally, to create an empty dictionary we can use {}.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#sets-and-frozen-sets",
    "href": "05-data-types-part2.html#sets-and-frozen-sets",
    "title": "5  Data Types for Multiple Values",
    "section": "5.5 Sets and Frozen Sets",
    "text": "5.5 Sets and Frozen Sets\nA set is another way to store multiple items into a single variable. Sets are unordered and unindexed. This means you cannot extract individual elements using their index like a list, nor by their key like a dictionary.\nYou can create a set by placing items (like integers or strings) inside curly brackets ({}) separated by commas:\n\nmyset = {'apple', 'banana', 'cherry'}\nmyset\n\n{'apple', 'banana', 'cherry'}\n\n\nSets cannot have duplicate items. It only keeps the unique values. For example, suppose we provide 'cherry' twice:\n\nmyset = {'apple', 'banana', 'cherry', 'cherry'}\nmyset\n\n{'apple', 'banana', 'cherry'}\n\n\nIt only keeps the first 'cherry'.\nYou are, however, able to add and remove elements to a set.\n\nmyset = {'apple', 'banana', 'cherry'}\nmyset.add('pear')\nmyset\n\n{'apple', 'banana', 'cherry', 'pear'}\n\n\n\nmyset = {'apple', 'banana', 'cherry'}\nmyset.remove('apple')\nmyset\n\n{'banana', 'cherry'}\n\n\nConverting a list to a set is useful if you want to get the list of unique elements:\n\nfruits = ['apple', 'apple', 'apple', 'banana', 'cherry', 'banana']\nset(fruits)\n\n{'apple', 'banana', 'cherry'}\n\n\nWe can iterate over sets just like lists (with for i in myset). We can also perform set operations on pairs of sets.\nFor example, for two sets A and B, we can find A\\cap B (the set of elements contained in both sets) using:\n\nset_a = {1, 2, 4, 6, 8, 9}\nset_b = {2, 3, 5, 7, 8}\nset_a.intersection(set_b)\n\n{2, 8}\n\n\nThe numbers 2 and 8 are the only numbers in both sets.\nTo find A\\cup B (the set of elements contained in either set) we can do:\n\nset_a.union(set_b)\n\n{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nThis gets all the numbers appearing in the two sets (dropping duplicates).\nTo find A\\setminus B (the set of elements in A not contained in B) we can do:\n\nset_a.difference(set_b)\n\n{1, 4, 6, 9}\n\n\n1, 4, 6 and 9 are in A and not in B. The number 2, for example, is not here because that is also in B.\nTo create a set that is immutable (so that you cannot add or remove items), you can use the frozenset() function:\n\nmyset = frozenset([1, 2, 3])\n\nYou can still use the same operations on frozensets as normal sets, except you cannot modify them once they are created.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html",
    "href": "06-defining-functions.html",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "",
    "text": "6.1 Introduction\nWe have used a number of Python functions so far, such as the absolute value function and the square root function. In this chapter we will learn how we can create our own functions. We will also learn how to use conditional statements inside functions.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#structure-of-a-function",
    "href": "06-defining-functions.html#structure-of-a-function",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.2 Structure of a Function",
    "text": "6.2 Structure of a Function\nWe will start off learning how to program a very basic function. Consider the function that returns its input plus one. Mathematically the function would be represented as:\n\nf(x)=x+1\n So f(0)=1, f(1)=2 and f(2)=3 and so on. In Python we can create this function with:\n\ndef add_one(x):\n    y = x + 1\n    return y\n\nThe def tells Python we are creating a function. We then provide the functions name (here add_one). After that we put in the function’s arguments in parentheses, separated by commas. Here there is only one argument so we just write x. Then like with a for loop we add a : and add the body of the function below it indented by 4 spaces. Here the only thing the function does is create y which is x + 1. We then get the function to return the output, which is y.\nLet’s try it out:\n\nadd_one(2)\n\n3\n\n\nWe get the expected output!\nOne thing to note about this function is that the y that is assigned x + 1 in the function is never stored in our environment. The y only exists within the function and is deleted after the function ends. We cannot access it outside. We say that y is a local variable (it is local to the function). It is possible to define global variables within a function that can be accessed after the function is called, but for our purposes doing so is generally not very good practice and so we will not cover that here.\nWe could also shorten our code by doing the calculation on the same line as the return command:\n\ndef add_one(x):\n    return x + 1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#commenting-in-python",
    "href": "06-defining-functions.html#commenting-in-python",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.3 Commenting in Python",
    "text": "6.3 Commenting in Python\nAs we start to write longer programs that include functions, it’s s good idea to start annotating your code to help other people understand its purpose (and also you when you look back at your own code after a couple of days!). We can do this by adding comments. In Python we can add a comment by using the # character. Everything after the # character is ignored by the Python interpreter, so what we write after it don’t need to be “legal” Python commands. We can add a comment to describe what a function does like this:\n\n# This function returns the input plus one:\ndef add_one(x):\n    return x + 1\n\nWe can also add comments to the same line as code we want to run provided we put it after the command. Like this:\n\n2 ** 3  # this command calculates 2 to the power of 3\n\n8",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#conditional-execution",
    "href": "06-defining-functions.html#conditional-execution",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.4 Conditional Execution",
    "text": "6.4 Conditional Execution\n\n6.4.1 If-Else Statements\nConditional statements, or “if-else statements”, are very useful and extremely common in programming. In an if-else statement, the code first checks a particular true/false condition. If the condition is true, it performs one action, and if the condition is false, it performs another action.\nA simple example of this is the absolute value function we saw in Chapter 3. Let’s define precisely what that function does:\n\n|x| = \\begin{cases}\n-x & \\text{ if } x &lt; 0 \\\\\nx & \\text{ otherwise}\n\\end{cases}\n\nIf x&lt;0 it returns -x, so that the negative number turns positive. Otherwise (if x=0 or it is positive), it keeps the value of x the same.\nAlthough Python already has an absolute value function (abs()), let’s create our own function (called my_abs()) that does the same thing. To do this we use conditional statements (if and else). Here’s how it works:\n\ndef my_abs(x):\n    if x &lt; 0:\n        y = -x\n    else:\n        y = x\n    return y\n\nThe function first checks if x&lt;0. If it is true, it performs the operation under if (sets y=-x) and skips past the else statement and returns y. If it is false (i.e. x \\not &lt; 0) then it skips past the operation under the if statement and instead does the operation under the else statement (sets y=x) before returning y.\nLet’s try it out using some different values:\n\n[my_abs(i) for i in [-2, 0, 3]]\n\n[2, 0, 3]\n\n\nJust like with the add_one() function above we can shorten this function definition. We could alternatively do:\n\ndef my_abs(x):\n    if x &lt; 0:\n        return -x\n    else:\n        return x\n\nThe function first checks if x&lt;0. If it is true, it returns -x and ends. It doesn’t go any further. If x \\not &lt; 0 then it skips the operation under if and does the operation under else (returns x).\nThis gives the same output:\n\n[my_abs(i) for i in [-2, 0, 3]]\n\n[2, 0, 3]\n\n\nThis means the return part of a function doesn’t have to be at the end of a function. But you should be aware that once a function returns a value it does not continue executing the remaining statements.\nFor example, consider the following code:\n\ndef bad_add_one(x):\n    return x\n    y = x + 1\n    return y\n[bad_add_one(i) for i in [1, 2, 3]]\n\n[1, 2, 3]\n\n\nThis is very similar to the first add_one() function we defined above. The only difference is that we write return x as the first command in the function’s body. Although the code sets y=x+1 and returns y, the output is always the same as the input. This is because the function returns x at the top, which means the rest of the function is never executed.\n\n\n6.4.2 If-Else If-Else Statements\nSometimes we want to do one thing if a certain condition holds, another thing if a different condition holds, and something else in the remaining cases. An example of this is the “sign” function, which tells you the sign in front of a value:\n\nsgn(x) = \\begin{cases}\n-1 & \\text{ if } x &lt; 0 \\\\\n0 & \\text{ if } x = 0 \\\\\n+1 & \\text{ otherwise} \\\\\n\\end{cases}\n If the value is negative, we get -1. If it’s zero we get 0. If it’s positive (the remaining case), we get +1.\nTo do this in Python, we could nest several if-else statements:\n\ndef sign(x):\n    if x &lt; 0:\n        return -1\n    else:\n        if x == 0:\n            return 0\n        else:\n            return 1\n[sign(i) for i in [-2, 0, 3]]\n\n[-1, 0, 1]\n\n\nThe function does the following:\n\nIf x&lt;0, return -1.\nOtherwise proceed to the next if-else:\n\nIf x=0, return 0.\nOtherwise (if x&gt;0), return 0.\n\n\nAlthough this works, this is quite complicated and difficult to follow. Some of the return statements are indented 4 times, for what should be such a simple function. For these kinds of situations we can make use of the elif statement. Here is an alternative way to make this function using elif:\n\ndef sign(x):\n    if x &lt; 0:\n        return -1\n    elif x == 0:\n        return 0\n    else:\n        return 1\n[sign(i) for i in [-2, 0, 3]]\n\n[-1, 0, 1]\n\n\nIn words, what the code does in this case is:\n\nIf the 1st check is true (x&lt;0), the function returns -1 and it done.\nIf the 1st check is false (x\\not &lt;0), the function checks x=0. If that is true it returns 0 and it done.\nIf the 1st and 2nd checks are false (x\\not &lt;0 and x\\neq 0), the function returns 1 and it done.\n\nIt actually does exactly the same as the first code, but because there is less nesting it is easier to follow and is preferred (especially when you have even more conditions to check!).\n\n\n6.4.3 While Loops\nA while loop is another very common method in programming. A while loop repeats a set of commands whenever a certain condition is true. A while loop also makes it possible to run an infinite loop. To have the sequence of numbers 1, 2, 3, \\dots printed on your screen forever (or until you kill the program) you could do:\nx = 0\nwhile True:\n    x += 1\n    print(x)\nNote: the x += 1 here is a shorter way of writing x = x + 1. The operations -=, *= and /= also work like this - try them out!\nBecause True will always be True, the loop will just keep running forever, adding 1 each time. Eventually the numbers will get so big that x will show up as inf (infinity), but you would have to let the program run for a very long time before you saw that.\nA while loop is also useful if you want to repeat a loop until something happens, but you don’t know how many times you need to run it before that happens. One instance when this would occur is if you wanted to numerically approximate a mathematical equation with an iterative algorithm. You want to repeat the iterations until the output starts to stabilize to a certain tolerance (accuracy) level, but you don’t know in advance how many iterations this will take. Let’s take a look at an example of this now.\nThe example we will look at is the way the ancient Greeks approximated square roots. Suppose you wanted to find the square root of x. What the ancient Greeks did is start with an initial guess of this y_0, let’s say \\frac{x}{2}. You then find the updated guess y_1 according to the formula: \ny_1 = \\frac{1}{2} \\left( y_0 + \\frac{x}{y_0}\\right)\n When you have y_1 we can update this for a more accurate approximation with: \ny_2 = \\frac{1}{2} \\left( y_1 + \\frac{x}{y_1}\\right)\n To write this in general terms, given an initial guess y_0, we update y_n, with n=1,2,\\dots according to: \ny_n = \\frac{1}{2} \\left( y_{n-1} + \\frac{x}{y_{n-1}}\\right)\n\nYou continue updating this way until y_n stops changing very much (for example it changes by less than 0.000001 in an iteration).\nLet’s work manually with this algorithm to see how well it works. Suppose we want the square root of 2 which we know is approximately equal to 1.414214. Let’s start with a guess y_0=\\frac{x}{2}=\\frac{2}{2}=1. This is quite far off the true 1.414214 but we’ll go with it anyway. We can update the guess with the formula:\n\ny_1 = \\frac{1}{2}\\left(y_0 + \\frac{x}{y_0}\\right) =\n\\frac{1}{2}\\left(1 + \\frac{2}{1}\\right) =1.5\n This is already a lot closer (0.0858 away). Let’s do the next approximation step:\n\ny_2 = \\frac{1}{2}\\left(y_1 + \\frac{x}{y_1}\\right) =\n\\frac{1}{2}\\left(1.5 + \\frac{2}{1.5}\\right) = 1.416667\n This is already pretty close (0.00245 away)! Let’s do one more:\n\ny_3 = \\frac{1}{2}\\left(y_2 + \\frac{x}{y_2}\\right) =\n\\frac{1}{2}\\left(1.416667 + \\frac{2}{1.416667}\\right) = 1.414216\n It’s now only 0.0000021 away from the precise answer! That might be close enough for most purposes, and we can always do another iteration to improve its accuracy.\nLet’s see how to code this in Python:\n\ndef my_sqrt(x, tol=0.000001):\n    # Arguments:\n    #  x   : number to take the square root of.\n    #  tol : tolerance level of algorithm.\n  \n    # Set initial guess:\n    y = x / 2\n  \n    # Initialize distance:\n    dist = tol + 1 \n    \n    # Update guesses until y changes by less than tol:\n    while dist &gt; tol:\n        # Previous guess:\n        y_old = y\n        # Update guess:\n        y = (y_old + x / y_old) / 2\n        # Calculate distance from last guess:\n        dist = abs(y - y_old)\n    return y\n\nWe have written a function that can take 2 arguments: x, the number we want to take the square root of, and tol, which is the tolerance level for how accurate our approximation should be (a lower number is more accurate). When we write tol=0.000001 in the function definition it means we say that 0.000001 is the default value for tol. If we don’t provide the argument it will use this value, but we can specify a different value if we want.\nWe now talk about the code in the function. The function first sets y_0=\\frac{x}{2} as the initial guess. It also needs to set dist = tol + 1 because the while loop checks if dist &gt; tol. For this check, dist needs to exist locally in the function (tol is created from the arguments). And for the while loop to run at least once the dist needs to start at a value bigger than tol. This is why we add one. Inside the while loop then, because we want to compare how our guess changes, we set y_old = y before setting the new y according to the approximation formula. Then we get the absolute value of the difference between the new and old guess. We then go back to the top of the loop and we check if dist is still bigger than tol. If it is, it repeats the steps again. If not, the while loop terminates and we go to the next stage, where y is returned as the output.\nLet’s try it out. First using the default value:\n\nmy_sqrt(2)\n\n1.414213562373095\n\n\nWe get an approximation that is very close to math.sqrt(2):\n\nimport math\nmath.sqrt(2)\n\n1.4142135623730951\n\n\nCan we specify a looser tolerance as follows:\n\nmy_sqrt(2, 0.1)\n\n1.4166666666666665\n\n\nAs expected, this is less accurate.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html",
    "href": "07-intro-to-numpy.html",
    "title": "7  Introduction to NumPy",
    "section": "",
    "text": "7.1 Introduction\nPython’s built-in data types like lists and tuples are not particularly well-suited for mathematical operations. We will show three examples of computations that we often need to do, and we will see that using lists involves quite a lot of coding to get the tasks done. We will then see that NumPy can do these tasks very efficiently.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#three-example-problems",
    "href": "07-intro-to-numpy.html#three-example-problems",
    "title": "7  Introduction to NumPy",
    "section": "7.2 Three Example Problems",
    "text": "7.2 Three Example Problems\n\nExample 1\nFor the first example, suppose we have a list x of numbers and we want to double each of the elements. We can’t use 2 * x because as we learned in Chapter 5 that just repeats the list twice. We have to do something like:\n\nx = [2, 4, 8]\ny = []\nfor i in x:\n    y.append(2 * i)\ny\n\n[4, 8, 16]\n\n\nWe create an empty list y. We then loop over the elements of x and append two times the element to y. This is very clunky. A better way of doing this is using a list comprehension:\n\nx = [2, 4, 8]\n[2 * i for i in x]\n\n[4, 8, 16]\n\n\nBut this is still a bit clunky. We would prefer a method that can just do 2 * x and get the same output.\n\n\nExample 2\nAnother example computation that we often need to do is if we have two lists of numbers x and y with the same number of elements and and we want to multiply them by each other element-by-element. Expressed in mathematical notation, suppose we have two vectors of numbers \\boldsymbol{x} and \\boldsymbol{y}: \n\\begin{split}\n\\boldsymbol{x}&=\\left[x_1, x_2, \\dots, x_n\\right] \\\\\n\\boldsymbol{y}&=\\left[y_1, y_2, \\dots, y_n\\right] \\\\\n\\end{split}\n and we want to calculate \\boldsymbol{z} from this which is:\n\\boldsymbol{z}=\\left[x_1 \\times y_2, x_2 \\times y_2, \\dots, x_n \\times y_n\\right]\n We can’t do x * y. That would return an error. But we could do this using a for loop:\n\nx = [2, 4, 8]\ny = [3, 2, 2]\nz = []\nfor i in range(len(x)):\n    z.append(x[i] * y[i])\nz\n\n[6, 8, 16]\n\n\nBecause we want to loop over the elements of both x and y, we have to loop over the indices 0, 1, 2. We could have written for i in [0, 1, 2], but range(len(x)) does this for us automatically (which is very useful if we have a long list). To see better what range is doing we can do:\n\nlist(range(5))\n\n[0, 1, 2, 3, 4]\n\n\nWe can see it creates a list from 0 up to but not including the argument.\nWe can improve on this code slightly by using the zip() function, which combines several iterables into one iterable.\n\nx = [2, 4, 8]\ny = [3, 2, 2]\nz = []\nfor i, j in zip(x, y):\n    z.append(i * j)\nz\n\n[6, 8, 16]\n\n\nSimilarly we can use zip() to do the task with a list comprehension:\n\nx = [2, 4, 8]\ny = [3, 2, 2]\n[i * j for i, j in zip(x, y)]\n\n[6, 8, 16]\n\n\nEven though we have now shortened the command down to one line, this last solution is still pretty clunky and also quite complicated. We would prefer an operation where we can just do x * y.\n\n\nExample 3\nFor the last example, suppose we want to find the median of a list of numbers. Recall that if the length of the list of numbers is odd, then the median is just the number in the middle when we sort the numbers. If the length of the list of numbers is even, then the median is the average of the two numbers closest to the middle when we sort the numbers.\nWe could create our own function to do this:\n\ndef median(x):\n    y = sorted(x)\n    if len(y) % 2 == 0:\n        return (y[len(y) // 2 - 1] + y[len(y) // 2]) / 2\n    else:\n        return y[len(y) // 2]\n\nThe function first sorts the list. The sorted() function gives the sorted list as the output. We do this instead of x.sort() because otherwise the function would sort our input list globally which we may not want it to do. The if len(y) % 2 == 0: checks if the length of the list is even. If it is even it takes the average of the element with index len(y) // 2 - 1 (just left of the middle) and the element with index len(y) // 2 (just right of the middle). We use // to ensure the division returns an integer instead of a float. If the length of the list is odd it returns the element with index len(y) // 2. Because len(y) / 2 is not an integer when len(y) is odd we use // to round down.\nLet’s test it out:\n\nmedian([2, 6, 4])\n\n4\n\n\n\nmedian([2, 6, 4, 3])\n\n3.5\n\n\nWe get the expected ouptut. However, this is quite complicated. We wouldn’t want to have to code this function every time we wanted to do something as common as finding the median.\nWe will see that functions from the module numpy can solve each of these problems (and a lot more) very easily.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#importing-the-numpy-module",
    "href": "07-intro-to-numpy.html#importing-the-numpy-module",
    "title": "7  Introduction to NumPy",
    "section": "7.3 Importing the NumPy Module",
    "text": "7.3 Importing the NumPy Module\nWe can import the numpy module using import numpy like with other modules. However it is conventional to load NumPy the following way:\n\nimport numpy as np\n\nThis way we can use the functions from NumPy with the shorter np instead of having to type numpy out in full every time. Doing this shortcut is okay because so many people do it that it’s easy for people to read. You can load other modules with shortcuts in a similar way, but you should follow the normal conventions when you can.\nNumPy works with arrays. An array is like a list but all elements must be of the same type (such as all floats). We can create an array using NumPy’s array function. Because we can shorten numpy to np, we can create an array with the function np.array() like this:\n\nimport numpy as np\nx = np.array([2, 4, 8])\nx\n\narray([2, 4, 8])\n\n\nWe will now show the power of NumPy by doing all the previous examples with very little code.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#solving-the-example-problems-with-numpy",
    "href": "07-intro-to-numpy.html#solving-the-example-problems-with-numpy",
    "title": "7  Introduction to NumPy",
    "section": "7.4 Solving the Example Problems with NumPy",
    "text": "7.4 Solving the Example Problems with NumPy\n\nExample 1\nTo double every number in array:\n\nx = np.array([2, 4, 8])\n2 * x\n\narray([ 4,  8, 16])\n\n\n\n\nExample 2\nTo multiply the elements of two arrays element-by-element:\n\nx = np.array([2, 4, 8])\ny = np.array([3, 2, 2])\nx * y\n\narray([ 6,  8, 16])\n\n\n\n\nExample 3\nTo get the median of an array:\n\nx = np.array([2, 6, 4])\nnp.median(x)\n\n4.0\n\n\n\nx = [2, 6, 4, 3]\nnp.median(x)\n\n3.5\n\n\nThe np.median() function also works if we just provide a list instead of an np.array:\n\nnp.median([2, 6, 4, 3])\n\n3.5\n\n\nThese are just a few examples of how NumPy can simplify coding drastically.\nFor many programming tasks we need to do, it’s very often many people had to do the same thing before. This means there is often a module available that can do the task. Of course we learn a lot from coding functions from scratch, but in order to complete a task quickly and efficiently it is usually better to use the modules made for the task.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#matrix-operations",
    "href": "07-intro-to-numpy.html#matrix-operations",
    "title": "7  Introduction to NumPy",
    "section": "7.5 Matrix Operations",
    "text": "7.5 Matrix Operations\nNumPy can also do matrix operations very easily. For example, suppose we had two 3 \\times 3 matrices \\boldsymbol{A} and \\boldsymbol{B}:\n\n\\boldsymbol{A}\n= \\left(\\begin{matrix}\n     1 & 2 & 3 \\\\\n     2 & 3 & 1 \\\\\n     3 & 1 & 3\n  \\end{matrix}\\right)\n\\qquad\n\\boldsymbol{B}\n= \\left(\\begin{matrix}\n    2 & 1 & 2 \\\\\n    3 & 2 & 1 \\\\\n    1 & 3 & 1 \\\\\n\\end{matrix}\\right)\n and wanted to calculate their product \\boldsymbol{C}=\\boldsymbol{AB}.\nManually, we could calculate each row i and column j of \\boldsymbol{C} with \\sum_{k=1}^3 a_{ik} b_{kj}. For example, row 2 and column 1 of \\boldsymbol{C} would be: \n\\begin{split}\nc_{21}&=\\sum_{k=1}^3 a_{2k} b_{k1}\\\\&=\na_{21} b_{11} +\na_{22} b_{22} +\na_{23} b_{33}\\\\\n&=\n2\\times2 + 3 \\times 3 + 1 \\times 1\\\\&=4+9+1\\\\&=14\n\\end{split}\n But doing this for all 9 elements would take a long time, and we could easily make a mistake along the way. Let’s use Python to calculate it instead.\nIf we were to try and do this with only built-in Python commands, it would still be rather complicated. We could define the matrices \\boldsymbol{A} and \\boldsymbol{B} using nested lists, where each list contains 3 lists representing the rows:\n\nA = [\n    [1, 2, 3],\n    [2, 3, 1],\n    [3, 1, 3]\n]\n\nB = [\n    [2, 1, 2],\n    [3, 2, 1],\n    [1, 3, 1]\n]\n\nTo calculate \\boldsymbol{C}=\\boldsymbol{AB} then we follow the same approach as the manual way. We loop through each row i and each column j of the matrix and calculate: c_{ij} = \\sum_{k=1}^3 a_{ik} b_{kj}. We do this by starting with a zero matrix and progressively fill it up.\n\nC = [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n]\n\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            C[i][j] += A[i][k] * B[k][j]\n\nfor row in C:\n    print(row)\n\n[11, 14, 7]\n[14, 11, 8]\n[12, 14, 10]\n\n\nThis is an example of a triple-nested loop: a loop inside a loop inside a loop.\nUsing NumPy to do the multiplication is much easier. We can just use the np.dot() function:\n\nimport numpy as np\nA = np.array(A)\nB = np.array(B)\nnp.dot(A, B)\n\narray([[11, 14,  7],\n       [14, 11,  8],\n       [12, 14, 10]])\n\n\nNumPy can also do many other matrix operations, such as:\n\ntransposing with the command np.transpose()\ninversion with the command np.linalg.inv().\n\nYou can therefore use Python to help you with the Mathematics course that you are taking alongside this one!",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "08-math-and-plotting.html",
    "href": "08-math-and-plotting.html",
    "title": "8  Mathematics and plotting",
    "section": "",
    "text": "8.1 Root finding\nConsider the function f(x) = x^2 + 2x - 1. A visualization of this function is given below. We will learn how to create this figure ourselves in Section 8.3.\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-3, 3, 600)\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, f(x), label='$f(x) = x^2 + 2x - 1$')\n\n# Add labels and title\nplt.title('Plot of the function f on the interval [-3,3]')\nplt.xlabel('x')\nplt.ylabel('f(x)')\n\n# Add a grid\nplt.grid(True)\n\n# Set range\nplt.xlim(-3,3)\nplt.ylim(-4,14)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\nIn our case, we want to solve the equation x^2 + 2x -1 = 0. You might remember from your high school math course that, for given numbers a, b and c, the roots of the quadratic function f(x) = ax^2 + bx + c, are given by\nx_\\ell = \\frac{- b - \\sqrt{b^2 - 4ac}}{2a} \\ \\ \\text{ and } \\ \\ x_r = \\frac{- b + \\sqrt{b^2 - 4ac}}{2a}\nwhere the subscript \\ell is used to denote the fact that this will be the “left” root and r to denote the “right” root.\nFor f(x) = x^2 + 2x-1, we have a = 1, b = 2 and c = -1. Plugging in these values in the formula above gives x_\\ell = -1 - \\sqrt{2} \\approx - 2.4142 and x_r = -1 + \\sqrt{2} \\approx 0.4142. Although this is an easy way to find the roots of a quadratic function, we want to be able to find roots of any function f, assuming they exist.\nThe easiest way to find a root of a general function is to use the the function fsolve() from the (sub)package scipy.optimize. This package contains many functions to carry out algorithmic tasks on mathematical functions. In order not having to write scipy.optimize the whole time we will import this package under the name optimize, just as we did with NumPy where we used the line import numpy as np. Below is the code snippet that carries out the root finding procedure.\nimport scipy.optimize as optimize\n\ndef f(x):\n    return x**2 + 2*x - 1\n\nguess = 3\nf_zero = optimize.fsolve(f,guess) \n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by [0.41421356]\nIn chronological order, this code does the following:\nThe use of fsolve() requires some additional explanation. It takes two input arguments, the first one being a (mathematical) function f and the second one an initial guess for where a root of f might be, which we store in the variable guess. Note that you cannot reverse the order of the input arguments: f_zero = optimize.fsolve(guess,f) does not work!\nWe could also have used optimize.fsolve(f,3) instead of separately defining guess = 3 and then using guess as input argument. However, when coding, it is common practice to always define input data (the number 3 in this case) in a separate variable. Especially if the number would be used in multiple places in your code, this is useful.\nIt is important to observe that a Python function can itself be an input argument of another Python function! That is, the function f is an input argument of the function fsolve(). It is required to define the f as a Python function. That is, it is not possible to use the command optimize.fsolve(x**2 + 2*x - 1,guess).\nThe second input argument guess is needed by fsolve() to execute the underlying mathematical root finding method that is used to find a root of f. We do not go into the actual mathematical method that is being carried out in the background by Python when we execute fsolve()1, but the idea is that the method starts at the guess that we provide and then gradually finds its way to a root of f by doing various calculations.\nIn fact, the choice of initial guess can influence the outcome of fsolve(). That is, a different initial guess can lead the underlying mathematical method to a different root of the function. This is illustrated in the code below, where we find the other root -2.4142....\nguess = -2\nf_zero = optimize.fsolve(f,guess)\n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by [-2.41421356]\nAs you might have noted, the output of optimize.fsolve(f,guess) is a list containing one number, for example, the last piece of code returned [-2.41421356]. If you instead only want to output the number -2.41421356, i.e., the value of the element in the string, you can use optimize.fsolve(f,guess)[0] instead. This means that what is stored in f_zero is the 0-th (and only) element of the list optimize.fsolve(f,guess).\nguess = -2\nf_zero = optimize.fsolve(f,guess)[0]\n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by -2.414213562373095\nWe can also use root finding to solve other types of equations. Suppose we want to compute an x such that \nf(x) = 6.\nMoving the 6 to the left, we see that this is the same as computing an x such that f(x) - 6 = 0. Therefore, if we define the function g(x) := f(x) - 6, then an x that satisfies g(x) = 0 also satisfies f(x) = 6, and vice versa. Let us code this as well.\ndef g(x):\n    return f(x) - 6\n    \nguess = 4\nf_zero = optimize.fsolve(g,guess)[0]\n\nprint(\"A number x satisfying f(x) = 6, is given by\", f_zero)\n\nA number x satisfying f(x) = 6, is given by 1.82842712474619\nThe function g works as follows: It computes f(x) by running the function f with the input x, and then substracting 6 from it. Note that we could have also defined g by returning x**2 + 2x - 1 - 6. It is, however, more convenient to just write f(x) - 6 here, because we have already defined the function f earlier. Also, if we would change the definition of the function f, the function g is automatically updated as well.\nEverything we have seen up till now also allows us to write a general Python function to solve an equation of the form \nf(x) = c\n for a given function f and number c. In the example above, we had c = 6.\ndef solve_eq(f,c,guess):\n    \"\"\" \n    Input\n    ----------\n    f : A mathematical function taking as input a variable x,\n    c : The right hand side value of the equation f(x) = c,\n    guess : The initial guess for fsolve().\n    \n    Returns\n    -------\n    A value x solving f(x) = c.\n    \"\"\"\n\n    def g(x):\n        return f(x) - c\n    \n    x = optimize.fsolve(g,guess)[0]\n    return x\nThe function above takes as input the function f, the number c and an initial guess that fsolve() can use. Let us try out solve_eq() on some input data. The goal will be to solve the equation\n3x^2 -4x + 1 = 5.\n#We create the function h(x) = 3x^2 - 4x + 1 \ndef h(x):\n    return 3*x**2 - 4*x + 1\n\n#Right hand side of the equation h(x) = 5\nd = 5 \n\n#Our initial guess for fsolve() (we choose 1 here).\ninitial_guess = 1 \n\nprint(\"A solution x to h(x) = d is given by\", solve_eq(h,d,guess))\n\nA solution x to h(x) = d is given by 2.0\nNote that the input arguments h, d and initial_guess need not have the same names as the local variables f, c guess in the function solve_eq(). What is important is that we input the arguments in the correct order in which we want them to be identified with the local variables. That is, by doing solve_eq(h,d,guess) Python knows that we want to assign the first input argument h to the first local variable f, the second input argument d to the second local variable c, and the third input argument initial_guess to the local variable guess.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "08-math-and-plotting.html#root-finding",
    "href": "08-math-and-plotting.html#root-finding",
    "title": "8  Mathematics and plotting",
    "section": "",
    "text": "A common task is to find a root x of a mathematical function f : \\mathbb{R} \\rightarrow \\mathbb{R}. A root is a point that satisfies the equation f(x) = 0.\n\n\n\n\n\n\n\n\n\nImport the optimize (sub)package from the scipy package.\nDefine f(x) = x^2 + 2x -1 as a Python function (Chapter 6).\nUse optimize.fsolve(f,guess) so that Python knows that we want to use the function fsolve() from optimize.\nThe argument that is returned by fsolve() is assigned to the variable f_zero.\nPrint a message containing the root of f that was found.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "08-math-and-plotting.html#minimization",
    "href": "08-math-and-plotting.html#minimization",
    "title": "8  Mathematics and plotting",
    "section": "8.2 Minimization",
    "text": "8.2 Minimization\nAnother fundamental task in mathematics is to find the minimum value that a function can attain. Recall the function f(x) = x^2+2x-1 from the previous section.\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-3, 3, 600)\n\n# Define the absolute value function\ndef f(x):\n    return x**2 + 2*x -1\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, f(x), label='$f(x) = x^2 + 2x - 1$')\n\n# Add labels and title\nplt.title('Plot of the function f on the interval [-3,3]')\nplt.xlabel('x')\nplt.ylabel('f(x)')\n\n# Add a grid\nplt.grid(True)\n\n# Set range\nplt.xlim(-3,3)\nplt.ylim(-4,14)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n It can be seen that the point x at which the function f is the lowest, i.e., attains its minimum is x = -1, and the function values in that point is f(-1) = -2. Python has various ways of finding the minimum of a function, the easiest-to-use being fmin() from the optimize module.\nThe syntax that is used for this function is similar to that of fsolve(). Although we already defined the function f in the previous section, we will redefine it in the code below for sake of completeness.\n\nimport scipy.optimize as optimize\n\ndef f(x):\n    return x**2 + 2*x - 1\n    \nguess = 1\nminimum = optimize.fmin(f,guess)\n\nprint('The minimum of the function f is attained at x = ', minimum)\n\nOptimization terminated successfully.\n         Current function value: -2.000000\n         Iterations: 19\n         Function evaluations: 38\nThe minimum of the function f is attained at x =  [-1.]\n\n\nNote that Python outputs some information in the console about the mathematical optimization procedure that was performed in order to find the minimum of the function. It displays the function value at the miminum that was found, in our case -2 = f(-1), and a number of iterations and function evaluations. These last two pieces of information are not relevant for us, but are useful for an expert who wants to understand better how well the optimization procedure performed. If you want, you can suppress all this information by adding disp=False or disp=0 as an argument to the fmin() function. This is illustrated below.\n\nminimum = optimize.fmin(f,guess,disp=False)\n\nprint('The minimum of the function f is attained at x = ', minimum)\n\nThe minimum of the function f is attained at x =  [-1.]\n\n\nAlso here, if you want to return only the value -1.0 instead of the list [-1.0] you can do the following as we illustrated for fsolve() as well.\n\nminimum = optimize.fmin(f,guess,disp=False)[0]\n\nprint('The minimum of the function f is attained at x = ', minimum)\n\nThe minimum of the function f is attained at x =  -1.0000000000000018",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "08-math-and-plotting.html#sec-visualization",
    "href": "08-math-and-plotting.html#sec-visualization",
    "title": "8  Mathematics and plotting",
    "section": "8.3 Visualization",
    "text": "8.3 Visualization\nIn this section we will explain the basics for plotting functions and data, for which we will use the matplotlib.pyplot (sub)package. We import it under the name plt. You might wonder why we use the name plt and not the perhaps more obvious choise plot. This is because plot() is a command that we will be using, so we do not want to create any conflicts with this function when executing a Python script.\nIn this section we will explain step-by-step how to generate the figure that we have seen in the previous two sections. We start with plotting the function f(x) = x^2 + 2x -1 for some values of x in a two-dimensional figure.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n    \n# Define the x range of x-values\nx = np.array([-3,-2,-1,0,1,2,3])\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nYou can view the figure in the Plots pane (or tab) in Spyder.\n\nIf the resolution of the plots in the Plots pane is bad, you can increase it by going to “Tools &gt; Preferences &gt; IPython console &gt; Graphics &gt; Inline backend &gt; Resolution” and set the resolution to, for example, 300 dpi.\n\n\nYou can get the Plots pane in fullscreen by going to the button with the three horizontal lines in the top right corner and choose “Undock”. You can “Dock” the pane again as well if you want to leave the fullscreen mode.\n\n\n\n\nIPython Console\n\n\nWe will next explain what the code above is doing. After defining the function f, we create the vector (i.e., Numpy array) \nx = [x_1,x_2,x_3,x_4,x_5,x_6,x_7] =  [-3,-2,-1,0,1,2,3].\n\nWe then compute the function values f(x_i) for i = 1,\\dots,7 and story these in the vector y. This might seem a bit strange. We defined the vector f as being a function that takes as input a number x and outputs the number f(x), but now we are inputting a whole vector of numbers x into the function f. Python is capable of handling this, and deals with this by returning the function value for every element of the vector x. That is, it will output the vector\n\n[f(x_1),f(x_2),f(x_3),f(x_4),f(x_5),f(x_6),f(x_7)] = [-3,-1,-2,-1,2,6,14].\n\nWe call f a vectorized function: At first glance, it is defined to have a single number as input, but it can also handle a vector as input, in which case it returns the function evaluation for every element of the vector. This typically only works when x is defined to be a Numpy array. If we would have defined x = [-3,-2,-1,0,1,2,3] as a list of numbers, the code would have given an error (try this yourself!).\n\nIf you use mathematical functions or functions from Numpy, Scipy or Matplotlib, it is best to store numerical input data for these functions in Numpy arrays (and not lists).\n\nNext, we create an (empty) figure using the command plt.figure(). Then comes the most important command, plt.plot(x,y), that plots the elements in the vector x against the elements in the vector y = f(x), and connects consecutive combinations (x_i,y_i) and (x_{i+1},y_{i+1}) with a line segment. For example, we have (x_1,y_1) = (-3,2) and (x_2,y_2) = (-2,-1). The left most line segment is formed by connecting these points.\nIf you only want to plot the points (x_i,y_i), and not the line segments, you can use plt.scatter(x,y) instead of plt.plot(x,y).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n    \n# Define the x range of x-values\nx = np.array([-3,-2,-1,0,1,2,3])\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.scatter(x, y)\n\n\n\n\n\n\n\n\n Observe that the (blue) line in the figure that was generated using plt.plot(x,y) is not as “smooth” as in the figures in the previous sections, where the function does not (visibly) have these segments. To get a smoother function line, we can include more points in the vector x.\nA quick way to generate a number k of evenly spaced points in the interval [a,b] is the command np.linspace(a,b,k) from the Numpy package. It takes as input the bounds of the interval [a,b] and the number of points k that we want to have in it. Consider the following example, where we want to generate k = 11 points in the interval [a,b] = [0,1].\n\nimport numpy as np\n\nx = np.linspace(0,1,11)\n\nprint(x)\n\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]\n\n\nNote that the end points of the interval form the first and last element in the vector x. “Evenly spaced” refers to the fact that the distance between two consecutive points in x is always the same. For this x this common distance is 0.1 = (b-a)/(k-1).\nLet us plot again the function f, but this time with 600 elements in x in the interval [-3,3]. We use plt.plot() again, instead of plt.scatter(). We now obtain a much smoother function line.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n    \n# Define the x range of x-values\nx = np.linspace(-3,3,600)\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y)\n\n\n\n\n\n\n\n\n You can add a legend for the line/points that you plot by using the label argument of plt.plot(). For example we can add the function description using plt.plot(x,y,label='$f(x) = x^2 + 2x - 1$'). This is in particular useful if you plot multiple functions in one figure, as the example below illustrates. There we plot the functions f and g, with g(x) = 3x a new function. To have the labels appear in the legend of the figure, you need to add a legend to the figure with plt.legend().\nIf you want to add labels to the horizontal and vertical axis, you can use the commands plt.xlabel() and plt.ylabel().\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Define the function g\ndef g(x):\n    return 3*x\n    \n# Define the x range of x-values\nx = np.linspace(-3,3,600)\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\nz = g(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y, label='$f(x) = x^2 + 2x - 1$')\nplt.plot(x, z, label='$g(x) = 3x$')\n\n# Create labels for axes\nplt.xlabel('x')\nplt.ylabel('Function value')\n\n# Create the legend with the specified labels\nplt.legend()\n\n\n\n\n\n\n\n\n You might observe that the range on the vertical axis changed now that we added a second function to the plot. When we only plotted the function f, the vertical axis ranged from -2 to 14, but now with the function g added to it, it ranges from -10 to 15.\nYou can fix the range [c,d] on the vertical axis using the command plt.ylim(c,d), and to fix the range of the horizontal axis to [a,b], you can use plt.xlim(a,b). In the figure below, we fix the vertical range to [c,d] = [-10,14] and the horizontal axis to [a,b] = [-3,3].\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Define the function g\ndef g(x):\n    return 3*x\n    \n# Define the x range of x-values\nx = np.linspace(-3,3,600)\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\nz = g(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y, label='$f(x) = x^2 + 2x - 1$')\nplt.plot(x, z, label='$g(x) = 3x$')\n\n# Create labels for axes\nplt.xlabel('x')\nplt.ylabel('Function value')\n\n# Create the legend with the specified labels\nplt.legend()\n\n# Fix the range of the axes\nplt.xlim(-3,3)\nplt.ylim(-10,14)\n\n\n\n\n\n\n\n\n Finally, you can also add a title to the plot using the command plt.title() as well as a grid in the background of the figure using plt.grid(). These are illustrated in the figure below.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Define the function g\ndef g(x):\n    return 3*x\n    \n# Define the x range of x-values\nx = np.linspace(-3,3,600)\n\n# Compute the function values f(x[i]) of the elements x[i] \n# and store them in the array y\ny = f(x)\nz = g(x)\n\n#Create the figure\nplt.figure()\n\n# Create the plot\nplt.plot(x, y, label='$f(x) = x^2 + 2x - 1$')\nplt.plot(x, z, label='$g(x) = 3x$')\n\n# Create labels for axes\nplt.xlabel('x')\nplt.ylabel('Function value')\n\n# Create the legend with the specified labels\nplt.legend()\n\n# Fix the range of the axes\nplt.xlim(-3,3)\nplt.ylim(-10,14)\n\n# Add title to the plot\nplt.title('A first plot in Python of two functions')\n\n# Add grid to the background\nplt.grid()\n\n\n\n\n\n\n\n\n This completes the description of how to plot figures like those we saw in the previous two sections. As a final remark, there are many more plotting options that we do not cover here. For example, with the plt.xticks() and plt.yticks() commands you can specify the numbers you want to have displayed on the horizontal and vertical axis, respectively. Also, there are commands to specify line color, width, type (e.g., dashed) and much more! You do not need to know this, but feel free to play around with such commands!",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  },
  {
    "objectID": "08-math-and-plotting.html#footnotes",
    "href": "08-math-and-plotting.html#footnotes",
    "title": "8  Mathematics and plotting",
    "section": "",
    "text": "In fact, there exist many root finding methods. A very famous one is Newton’s method developed by Isaac Newton, a famous sciencist that you might have heard of. The reason why there are so many root finding methods is that some work better than others on a given function f. There are other ways to do root finding in Python that allow you to specify a root finding method yourself, but this is a more advanced topic beyond the scope of this course.↩︎",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mathematics and plotting</span>"
    ]
  }
]