[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "",
    "text": "1 About",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.1 Welcome",
    "text": "1.1 Welcome\nWelcome to the online “book” for the Programming Module of the TiSEM Minor Essential Digital Skills. We will follow the content in this book during the lectures and is the basis of the material that will appear on the exam, so you should read through this book carefully. Because this book is new, it is likely that we will make some edits throughout the course.\nBefore jump into coding with Python, we will start by discussing what programming is at the most basic level and motivating why we are learning how to code in Python in the first place.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-a-programming-language",
    "href": "index.html#what-is-a-programming-language",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.2 What is a Programming Language?",
    "text": "1.2 What is a Programming Language?\nWithout getting into a complicated details, a programming language is a way to communicate to a computer via written text in a way that the computer can understand so that you can instruct it to do various operations for you. This is very different to how we often usually interact with a computer, which often involves pointing and clicking on different buttons and menus with your mouse.\nKnowing how to program is a very useful skill because you can automate repetitive tasks that would otherwise take you a very long time if you had to them “by hand” (i.e. by clicking things with your mouse). For example, suppose you work in a hotel in a city and you need to check how much your competitors are charging for rooms on different days so that you can adjust prices to stay competitive. Every day you have to go to all the different websites of the competing hotels and take note of the prices in an Excel sheet. With programming, what you could do instead is write code that tells the computer to automatically visit those websites every day, record the hotel room prices, and put them in an Excel sheet for you. This is a process called web scraping and can be done with Python. This is just one example of the many ways programming languages can automate repetitive tasks.\nWhen humans speak to each other and someone makes a grammar mistake, it usually isn’t a big deal. We usually know what they mean. But if you make a “syntax error” in a programming language, it won’t understand what you mean. The computer will throw an error or. That is worse still is a “semantic error” which is when the computer runs your code without error but does something you didn’t want it to do. Therefore we need to be very careful when writing in a programming language.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#why-python",
    "href": "index.html#why-python",
    "title": "Programming for TiSEM Essential Digital Skills",
    "section": "1.3 Why Python?",
    "text": "1.3 Why Python?\nThere are many different programming languages out there: C, C++, C#, Java, JavaScript, R, Julia, Stata, MATLAB, Fortran, Ruby, Perl, Rust, Go, Lua, Swift - the list goes on. So why should we learn Python over these other alternatives?\nThe best programming language depends on what task you want to accomplish. Are you building a website, writing computer software, creating a game, or analyze data? While many languages could perform all these tasks, some languages excel in some of them. In this course our goal is to learn basic programming techniques required for data science, and Python is by far the most popular programming lanaguage for this task. But it’s not only useful for that. It is also often used in web development, creating desktop applications and games, and for scientific computations. It is therefore a very versatile programming language that can complete a very wide range of tasks.\nPython is also completely free and open source and can run on all common operating systems. This means you can share your code with anyone and they will be able to run it, no matter what computer they are on or where they are in the world.\nThere is also a very large active community that creates packages to do a wide-range of operations, keeping Python up to date with the latest developments. For example, excellent community help is available at Stackoverflow, so if you Google how to do something in Python most likely that question has already been answered on Stackoverflow. Funnily enough, a key skill to develop with programming is how to formulate your question into Google to land on the right Stackoverflow page. Stackoverflow used to be the main source of online help for Python, but recently Chat GPT is becoming more common. Chat GPT can write excellent Python code and also explains all the steps it takes, so I encourage you to use it to help learn (although it won’t be available to you in the exam, so don’t become too reliant on it!).\nThese days employers are increasingly looking to hire people with programming skills. Knowing how to program in Python - one of the most commonly used languages by companies - is therefore a very valuable addition to your CV.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html",
    "href": "02-getting-started.html",
    "title": "2  Getting Started",
    "section": "",
    "text": "2.1 Installing Anaconda\nThe easiest way to install Python is by installing Anaconda. You can do this by visiting https://www.anaconda.com/download.\nYou should see this page:\nYou should click the “Skip registration” button (although feel free to register if you like). You will then see the following page:\nYou should then click on the “Download” button. Mac users will see a Mac logo instead.\nAfter downloading the file, click on it to install it. Follow the installation wizard and keep all the default options during installation.\nAfter installation you will see a number of new applications on your computer. These are:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#installing-anaconda",
    "href": "02-getting-started.html#installing-anaconda",
    "title": "2  Getting Started",
    "section": "",
    "text": "Anaconda Download Page\n\n\n\n\n\n\nAnaconda Download Page\n\n\n\n\n\n\nSpyder. This is a computer application that allows you to write Python scripts and execute them to see the output. Such an application is called an Integrated Desktop Environment (IDE). We will see how to use this below.\nJupyter Notebook. This is a web application that allows you to write a notebook (like a report) with text and Python code snippets with output. We will learn how to use this application later in this course.\nAnaconda Prompt. This is a way to manage and update packages from the command line. Packages are collections of modules that give Python more functionality, allowing you to perform different types of tasks more easily. All the packages that we will need for this course are installed by default when we install Anaconda, so we will not need to use this in this course.\nAnaconda Navigator. This is a graphical user interface for the Anaconda prompt. This essentially allows you to manage your packages without having to learn the different commands required by the Anaconda prompt. We won’t need to use this application in this course.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#spyder",
    "href": "02-getting-started.html#spyder",
    "title": "2  Getting Started",
    "section": "2.2 Spyder",
    "text": "2.2 Spyder\nOpen the Spyder program installed by Anaconda. You should see an application that looks like this:\n\n\n\nSpyder\n\n\n\n2.2.1 Python Console\nIn the bottom right pane you see a console with IPython. IPython is short for Interactive Python. We can type Python commands into this console and see the output directly. To find 1+1 in Python, we can use the command 1+1, similar to how we would do it in Excel or in the Google search engine. Let’s try this out in the console. First, click on the console to move the cursor there. Then type 1+1 and press Enter. We will see the output 2 on the next line next to a red Out [1]:\n\n\n\nIPython Console\n\n\nThe red Out [1] means this is the output from the first line of input (after the green In [1]). The second command will have input In [2] and output Out [2].\n\n\n2.2.2 Python Scripts\nTyping commands directly into the IPython console is fine if all you want to do is try out a few different simple commands. However, when working on a project you will often be executing many commands. If you were to do all of this in the interactive console it would be very easy to lose track of what you are doing. It would also be very easy to make mistakes.\nWriting your commands in Python scripts is a solution to this problem. A Python script is a text file with a .py extension where you can write all of your commands in the order you want them run. You can then get Spyder to run the entire file of commands. You can also ask it to only run part of the file. This has many advantages over typing commands into the console:\n\nIf you have run 10 commands to calculate something and then afterwards you decide to change what happened in one of the earlier commands, you would often have type all the commands again. In a script you would just need to edit the line with that command. So scripts can save you a lot of time.\nYou or anyone else can easily reproduce your work by re-running the Python script.\nBy having all the commands in a script you can more easily spot any mistakes you might have.\nIt is a way of saving your work.\n\nTherefore it’s best practice to write your code in scripts. In the exam, you will also have to supply your script with your answers.\nIn Spyder, in the left pane you see a file open called temp.py. This is an example Python script. We can ignore what is written in the first 6 lines of the script. We can add our 1 + 1 command to the bottom of the script like this and save it:\n\n\n\nPython Script\n\n\nIn the Toolbar there are several ways to run this command from the script. For example, you can run the entire file, or run only the current line or selected area. If the cursor is on the line with 1 + 1 and we press the “Run selection or current line” button, then we will see the command and output appear in the IPython console, just like how we typed it there before. Using the script, however, we have saved and documented our work.\nIf you try run the entire file, you will see runfile('...') in the IPython console with the ... being the path to the Python script you are running. However, you don’t see a 2 in the output. This is because when running an entire file, Python does not show the output of each line being run. To see the output of any command we need to put it inside the print() function. We can change our line to print(1 + 1) to see the output when running the entire file:\n\n\n\nUsing the print() function\n\n\nWhen you run the entire file you should now see a 2 below the runfile('...') command.\nWe now know how to write and run Python scripts! In the next chapter we will learn more Python commands.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "02-getting-started.html#code-snippets-in-this-book",
    "href": "02-getting-started.html#code-snippets-in-this-book",
    "title": "2  Getting Started",
    "section": "2.3 Code Snippets in This Book",
    "text": "2.3 Code Snippets in This Book\nIn this book, we won’t always show screenshots like we did above. Instead we will show code snippets in boxes like this:\n\n1 + 1\n\n2\n\n\nThe part that is code will be in color and there will be a small clipboard icon on the right which you can use to copy the code to paste into your script to be able to experiment with it yourself. The output from the code will always be in a separate gray box below it (without a clipboard icon).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html",
    "href": "03-python-as-a-calculator.html",
    "title": "3  Python as a Calculator",
    "section": "",
    "text": "3.1 Addition, Subtraction, Multiplication and Division\nWe start with the most basic operations. Addition, subtraction, multiplication and division are given by the standard +, -, * and / operators that you would use in other programs like Excel. For example:\nAddition:\n2 + 3\n\n5\nSubtraction:\n5 - 3\n\n2\nMultiplication:\n2 * 3\n\n6\nDivision:\n3 / 2\n\n1.5\nIt is also possible to do multiple operations at the same time using parentheses. For example, suppose we wanted to calculate: \n\\frac{2+4}{4\\times 2} = \\frac{6}{8} = 0.75\n We can calculate this in Python as follows:\n(2 + 4) / (4 * 2)\n\n0.75",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#troubleshooting-escaping-in-python",
    "href": "03-python-as-a-calculator.html#troubleshooting-escaping-in-python",
    "title": "3  Python as a Calculator",
    "section": "3.2 Troubleshooting: “Escaping” in Python",
    "text": "3.2 Troubleshooting: “Escaping” in Python\nSuppose by accident you left out the closing parentheses above. You typed (2 + 4) / (4 * 2 and Enter. You don’t see the output but instead see\nIn [1]: (2 + 4) / (4 * 2\n   ...:\nPython did not run the command, but it also did not give an Error. What happened is that because there was no closing parenthesis Enter moved to a new line instead of executing the command. To “Escape” this situation, you just need to press the Ctrl+C button. In general, if anything strange happens in Python and you get stuck, you can always press Ctrl+C in the console to escape the current command.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#exponentiation-taking-powers-of-numbers",
    "href": "03-python-as-a-calculator.html#exponentiation-taking-powers-of-numbers",
    "title": "3  Python as a Calculator",
    "section": "3.3 Exponentiation (Taking Powers of Numbers)",
    "text": "3.3 Exponentiation (Taking Powers of Numbers)\nx^n multiplies x by itself n times. For example, 2^3=2\\times 2\\times 2 = 8. In Python we use ** to do this:\n\n2 ** 3\n\n8\n\n\nBe very careful not to use ^ for exponentiation. This actually does a very different thing that we won’t have any use for in this course.1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#absolute-value",
    "href": "03-python-as-a-calculator.html#absolute-value",
    "title": "3  Python as a Calculator",
    "section": "3.4 Absolute value",
    "text": "3.4 Absolute value\nTaking the absolute value turns a negative number into the same number without a minus sign. It has no effect on positive numbers.\nIn mathematics notation we write |x| for the absolute value of x. The formal definition is:\n\n|x| = \\begin{cases} x & \\text{ if } x \\geq 0 \\\\ -x & \\text{ otherwise}\n\\end{cases}\n\nHere are some examples:\n\n|-2|=2\n|3|=3.\n\nThis is what the function looks like when we plot it for different x:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-10, 10, 400)\n\n# Define the absolute value function\ny = np.abs(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = |x|')\n\n# Add labels and title\nplt.title('Absolute Value Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nWe’ll learn how to make plots like this later in this course.\nIn Python we can calculate absolute values with:\n\nabs(-2)\n\n2\n\n\n\nabs(3)\n\n3\n\n\nTaking the absolute value in Python involves using what is called a function. Functions are used by calling their names and giving the arguments to the function in parentheses. When we do abs(-2), abs is the name of the function and -2 is the argument.\nIn many ways the functions in Python work a lot like the functions in Excel, just they might have different names or be used a bit differently. For example, in Excel you write =ABS(-2) to take the absolute value of -2. The argument is the same, and the function name only differs in that in Excel you need to use capital letters whereas in Python you use lowercase letters (in addition, Excel requires you to put an = before the function name).\nWhen using functions it is helpful to read their help pages. You can look at this by typing help(abs) in the Console and pressing Enter. We then see:\nHelp on built-in function abs in module builtins:\n\nabs(x, /)\n    Return the absolute value of the argument.\nThis tells us that abs() takes a single argument and returns the absolute value.\nWe will be using many different functions and it’s a good habit of to look at their help pages. The help pages will be available to you in the Exam.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#square-roots",
    "href": "03-python-as-a-calculator.html#square-roots",
    "title": "3  Python as a Calculator",
    "section": "3.5 Square Roots",
    "text": "3.5 Square Roots\nThe square root of a number x is the y that solves y^2=x. For example, if x=4, both y=-2 and y=2 solve this. The principal square root is the positive y from this.\nHere is what the square root function looks like for different x:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range (positive values because np.sqrt() not defined for negative\n# values)\nx = np.linspace(0, 10, 400)\n\n# Define the square root function\ny = np.sqrt(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = √x')\n\n# Add labels and title\nplt.title('Square Root Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nThe principal square root a number is equal to the number exponentiated by \\frac{1}{2}:\n\n\\sqrt{x} = x^\\frac{1}{2}\n\n\n9 ** (0.5)\n\n3.0\n\n\nWe can follow a very similar approach to above to get the cubed root of a number, such as: \\sqrt[3]{8}=8^\\frac{1}{3}=2:\nIn Python:\n\n8 ** (1/3)\n\n2.0\n\n\nPython also has a square root function, but it is not built in. We need to load this function by loading the module math. A module is a collection of additional functions and other objects that we can load in our Python script. The module math contains many mathematical functions, including the sqrt() function.\nTo load the math module, we need to include import math in our script before executing any of its functions. To run the sqrt() function from the math module, we need to type math.sqrt(). This “dot” notation means we use the sqrt() function within the math module.\nTo get \\sqrt{9} then we can do:\n\nimport math\nmath.sqrt(9)\n\n3.0\n\n\nTo view the help page math.sqrt(), we can use help(math.sqrt).\nIf you only want to use the sqrt() function from the math module, you could alternatively import the function the following way:\n\nfrom math import sqrt\nsqrt(9)\n\n3.0\n\n\nThis way you don’t need to type math.sqrt() every time you want to take the square root, and only need to type sqrt(). However, it is generally preferred practice to import the math module using import math and use the function with math.sqrt(). This makes the code clearer and easier to understand.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#exponentials",
    "href": "03-python-as-a-calculator.html#exponentials",
    "title": "3  Python as a Calculator",
    "section": "3.6 Exponentials",
    "text": "3.6 Exponentials\nA very important function in mathematics and statistics is the exponential function. The definition of \\exp\\left(x\\right), or e^x, is given by: \ne^x = \\underset{n\\rightarrow \\infty}{\\lim} \\left(1 + \\frac{x}{n}\\right)^n\n\nNote: you don’t need to know or remember this definition for the exam. You only need to know how to calculate the exponential function in Python.\nThis is what the function looks like:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-2, 2, 400)\n\n# Define the exponential function\ny = np.exp(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, y, label='y = e^x')\n\n# Add labels and title\nplt.title('Exponential Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nIn Python we can use the exp() function from the math module to calculate the exponential of any number:\n\nmath.exp(1)\n\n2.718281828459045",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#logarithms",
    "href": "03-python-as-a-calculator.html#logarithms",
    "title": "3  Python as a Calculator",
    "section": "3.7 Logarithms",
    "text": "3.7 Logarithms\nAnother common mathematical function is the logarithm, which is like the reverse of exponentiation.\nThe log of a number x to a base b, denoted \\log_b\\left(x\\right), is the number of times we need to multiply b by itself to get x. For example, \\log_{10}\\left(100\\right) = 2, because 10\\times 10=100. We need to multiply the base b=10 by itself twice to get to x=100.\nA special logarithm is the natural logarithm, \\log_e(x), which is the logarithm to the base \\exp(1)=e^1\\approx 2.7183. This is also written as \\ln(x).\nThis is what the function looks like:\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range (positive values only, since ln(x) is undefined for non-positive x)\nx = np.linspace(0.1, 10, 400)  # Start from 0.1 to avoid log(0), which is undefined\n\n# Define the natural logarithm function\ny = np.log(x)\n\n# Create the plot\nplt.figure(figsize=(6, 4))\n\nplt.plot(x, y, label='y = ln(x)')\n\n# Add labels and title\nplt.title('Natural Logarithm Function')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Add a grid\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nIn Python we use the log() function from the math module to calculate the natural logarithm:\n\nimport math\nmath.log(1)\n\n0.0\n\n\nWhat if we want to calculate the logarithm to a base other than e? If we look at the help page for log() using help(math.log), we see:\nHelp on built-in function log in module math:\n\nlog(...)\n    log(x, [base=math.e])\n    Return the logarithm of x to the given base.\n    \n    If the base not specified, returns the natural logarithm (base e) of x.\nWe can see that the log() function can take 2 arguments:\n\nx: the number we want to take the log of.\nbase: the base with respect to which the logarithms are computed. The default is math.e which equals the value of e\\approx 2.718. Because this argument is contained in a square bracket, it means it is an optional argument. If we don’t provide it it will use the default.\n\nThis is the first time that we have seen a function with more than one argument. Earlier when we used the math.log() to calculate the natural logarithm we only used one argument because we used the default setting for the base. But when we want to use a base other than e, we need to specify it.\nHow we calculate \\log_{10}\\left(100\\right) in Python is as follows:\n\nimport math\nmath.log(100, 10)\n\n2.0\n\n\nWe write both arguments into the math.log() function, separated by commas.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#integer-division-and-the-modulus-operator",
    "href": "03-python-as-a-calculator.html#integer-division-and-the-modulus-operator",
    "title": "3  Python as a Calculator",
    "section": "3.8 Integer Division and The Modulus Operator",
    "text": "3.8 Integer Division and The Modulus Operator\nWhen we divide 7 by 3 we get 2\\frac{1}{3}. We could alternatively say that “7 divided by 3 equals 2 with remainder 1”. When programming it is often useful to get to get these numbers.\nWe can perform “integer division” with the // operator. This always returns the fraction rounded down to the nearest whole number:\n\n7 // 3\n\n2\n\n\nTo get the remainder we use the modulus operator %:\n\n7 % 3\n\n1\n\n\nTogether then 7/3 is 2 with remainder 1.\nOne thing to note is that integer division with negative numbers doesn’t round to the integer closest to zero, but always down. So:\n\n-7 // 3\n\n-3\n\n\nand:\n\n7 // -3\n\n-3\n\n\nboth give -3 and not -2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "03-python-as-a-calculator.html#footnotes",
    "href": "03-python-as-a-calculator.html#footnotes",
    "title": "3  Python as a Calculator",
    "section": "",
    "text": "For example, 2^3 converts 2 and 3 to binary (10 and 11 respectively) and then does a “bitwise excluse OR operation” on these (which results in 01) and converts it back to in integer (which is 1). So 2 ** 3 gives 8 but 2^3 gives 1.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python as a Calculator</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html",
    "href": "04-data-types-part1.html",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "4.1 Variables\nIn Python we can assign single values to variables and then work with and manipulate those variables.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#variables",
    "href": "04-data-types-part1.html#variables",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "4.1.1 Assigning Values to Variables\nAssigning a single value to a variable is very straightforward. We put the name we want to give to the variable on the left, then use the = symbol as the assignment operator, and put the value to the right of the =. The = operator binds a value (on the right-hand size of =) to a name (on the left-hand side of =).\nTo see this at work, let’s set x=2 and y=3 and calculate x+y:\n\nx = 2\ny = 3\nx + y\n\n5\n\n\nIn Spyder there is a “Variable Explorer” in the top-right pane to see the variables we have created:\n\n\n\nVariable Explorer in Spyder\n\n\nWe can see that x has a value 2 and y has a value 3.\nWhen we assign x=2, in our code, the value is not fixed forever. We can assign a new value to x. For example, we can assign the number 6 to x instead:\n\nx = 6\nx + y\n\n9\n\n\n\n\n4.1.2 Rules for Naming Variables\nVariable names can be multiple letters long and can contain underscores (_). Underscores are useful because variable names cannot contain spaces and so we can use underscores to represent spaces. Variable names can contain numbers but they cannot start with one. For example x1 and x_1 are legal names in Python, but 1x is not. There are 35 keywords that are reserved and cannot be used as variable names because they are fundamental to the language. For example, we cannot assign a value to the name True, because that is a keyword. Below is the list of all keywords.1 We will learn what many of these keywords are later in this course and how to use them.\n\nimport keyword\nprint(keyword.kwlist, end=' ')\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#common-data-types-for-single-values",
    "href": "04-data-types-part1.html#common-data-types-for-single-values",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.2 Common Data Types for Single Values",
    "text": "4.2 Common Data Types for Single Values\n\n4.2.1 Integers\nYou may have noticed that the “Variable Explorer” in Spyder had a “Type” column. For x and y this was int which means “integer”. Integers are whole numbers that can also be negative. We can also check the type of a variable using the type() function:\n\ntype(x)\n\nint\n\n\n\n\n4.2.2 Floating-Point Numbers\nNumbers that are not whole numbers have the type float, which stands for floating-point number:\n\ntype(1.2345)\n\nfloat\n\n\nAll the operations we learned about in Chapter 3 also work with floating-point numbers. For example:\n\n1.2 * 3\n\n3.5999999999999996\n\n\nYou will notice that we don’t get 3.6 like we expected, but instead something very very close but slightly different to 3.6. This is because of how floating-point numbers are represented internally by the computer. The number is split into an integer with a fixed degree of precision and an exponential scaler. For example 1.2 is the same as 12\\times 10e^{-1}, so the computer needs two integers: 12 and -1 (the exponent) to represent 1.2. Because this process involves some approximations when we perform arithmetic operations on them we can lose some accuracy. However, for most purposes 3.5999999999999996 is close enough to 3.6.\n\n\n4.2.3 Strings\nPython can also work with text in the form of strings. Text in Python needs to be wrapped in quotes. These can be either single quotes (') or double quotes (\"), provided they match.\n\ntype('Hello world')\n\nstr\n\n\n\ntype(\"This is a string\")\n\nstr\n\n\nThis str means it is a “string” which is a sequence of individual characters.\nOne thing to be careful with strings is that if you have a string that contains double quotes you have to wrap it in single quotes and vice versa:\n\nquote = 'Descartes said \"I think, therefore I am\" in 1637'\napostrophe = \"Don't wrap this with single quotes!\"\n\nIf you find yourself in the unusual situation with a string with both single and double quotes, you can wrap them in triple single quotes ('''):\n\nquote_with_apostrophe = '''As they say \"Don't judge a book by its cover\"'''\n\nAnother thing to be careful with strings is that numbers surrounded by quotes are strings and not numbers:\n\ntype(\"1.2\")\n\nstr\n\n\nWe can use some of the operators for numbers on strings, but they do very different things. The + operator combines strings:\n\na = \"Hello, \"\nb = \"world\"\na + b\n\n'Hello, world'\n\n\nAnd the * operator repeats strings:\n\na = \"Hello! \"\na * 3\n\n'Hello! Hello! Hello! '\n\n\n\n\n4.2.4 Boolean Values\nIn programming it is often useful to work with variables that are either true or false. Therefore Python has a special data type for this called the Boolean data type. This is named after George Boole who was a mathematics professor in Ireland in the 1800s.\nThe Boolean values are either True or False. The words must be capitalized and spelled exactly this way. These are two of Python’s keywords.\n\na = True\nb = False\ntype(a)\n\nbool\n\n\nTrue and False are 2 of the keywords that cannot assign values to. Try 2 = True yourself and see the error that you get.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#logical-and-comparison-operators",
    "href": "04-data-types-part1.html#logical-and-comparison-operators",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.3 Logical and Comparison Operators",
    "text": "4.3 Logical and Comparison Operators\n\n4.3.1 Logical Operators\nBoolean values have their own operations: and, or and not. These are called logical operators. These work as follows:\n\na and b is True if both a and b are True. Otherwise it is False (if either or both of a or b are False).\na or b is True if either a or b (or both) are True. Otherwise it is False (if both a and b are False).\nnot a is True if a is False and is False if a is True. The not operator flips the value.\n\nLet’s try them out on a and b:\n\na and b\n\nFalse\n\n\nThis is False because we need both a and b to be True.\n\na or b\n\nTrue\n\n\nThis is True because at least one of a or b is True.\n\nnot a\n\nFalse\n\n\nThis is False because a is True. It flips the value.\n\n\n4.3.2 Comparison Operators\nPython has operators to check if one number is equal to, not equal to, greater than (or equal to), or less than (or equal to) another number. It checks the (in)equality and returns True or False depending on the result.\nTo check if a=b, we use the == operator:\n\na = 3\nb = 2\na == b\n\nFalse\n\n\na\\neq b, so we get False. Be careful to use two equal symbols and not one. If we did a = b, it would just reassign to a the value of b (2):\n\na = 3\nb = 2\na = b\na\n\n2\n\n\nTo check if a\\neq b, we use the != operator (which is supposed to look like the \\neq symbol):\n\na = 3\nb = 2\na != b\n\nTrue\n\n\nThis is True, because a and b are not equal.\nTo see if a&gt;b, we use &gt; and to see if a\\geq b we use a &gt;= b:\n\na = 3\nb = 2\na &gt;= b\n\nTrue\n\n\nWe get True because a\\geq b.\nTo see if a&lt;b, we use &lt; and to see if a\\leq b we use a &lt;= b:\n\na = 3\nb = 2\na &lt;= b\n\nFalse\n\n\nWe get False because a\\ngeq b.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#type-conversion",
    "href": "04-data-types-part1.html#type-conversion",
    "title": "4  Variables and Data Types for Single Values",
    "section": "4.4 Type Conversion",
    "text": "4.4 Type Conversion\nWe can sometimes convert objects between int, float, str and bool. Sometimes this conversion is not so intuitive so you need to be careful and know how it works.\nIf we assign x=1, it will automatically be made an int:\n\nx = 1\ntype(x)\n\nint\n\n\nBut we can convert x to a float using the float() function. Let’s assign y to be x as a float:\n\ny = float(x)\ntype(y)\n\nfloat\n\n\n\ny\n\n1.0\n\n\nWe can see that y is not 1 but 1.0. The .0 helps us recognize that this is a float.\nWe can also convert the integer to a string:\n\nz = str(x)\ntype(z)\n\nstr\n\n\n\nz\n\n'1'\n\n\nThe quotes around the 1 helps us recognize that this is a string.\nFinally we can also convert from a float to a string:\n\nstr(y)\n\n'1.0'\n\n\nIf you have an integer stored as a string, we can convert it back to an integer:\n\nint(\"1\")\n\n1\n\n\nOr you can convert it to a float:\n\nfloat(\"1\")\n\n1.0\n\n\nAnd if a float is stored as a string, we can convert it back to a float:\n\nfloat(\"1.5\")\n\n1.5\n\n\nHowever, it is not possible to convert \"1.5\" to an integer - that will return an error. Similarly you cannot convert strings with characters to integers or floats.\nWe can also convert floats to integers:\n\nint(1.0)\n\n1\n\n\nIf we try to convert a float that isn’t a whole number to an integer it will always take the closest integer to zero. For positive numbers this means it always rounds down:\n\nint(1.1)\n\n1\n\n\n\nint(1.9)\n\n1\n\n\nAnd for negative numbers it always rounds up:\n\nint(-2.1)\n\n-2\n\n\n\nint(-2.9)\n\n-2\n\n\nThe Boolean values True and False can be converted to integers, floats and stringers. True becomes 1, 1.0 and 'True' and False becomes 0, 0.0 and 'False', respectively. We can also convert integers 1 and 0 back to Boolean:\n\nbool(1)\n\nTrue\n\n\n\nbool(0)\n\nFalse\n\n\nHowever, if we try convert strings to Boolean we get some unintuitive results. For example:\n\nbool('0')\n\nTrue\n\n\n\nbool('False')\n\nTrue\n\n\nNon-empty strings always return True. Only empty strings return False:\n\nbool('')\n\nFalse\n\n\nThis is an example of when a programming language does something unintuitive. Therefore when writing a longer program you really need to be sure what each line is doing, otherwise your program will do something unexpected.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "04-data-types-part1.html#footnotes",
    "href": "04-data-types-part1.html#footnotes",
    "title": "4  Variables and Data Types for Single Values",
    "section": "",
    "text": "The keyword module contains functions for testing if a string is a keyword. The command keyword.kwlist returns the full list of keywords. You will notice I wrote print(keyword.kwlist, end = ' ') to print the words. I write end = ' ' so that all the keywords are printed on a single line instead of all on their own line to save space. The default line ending for print() is \\n (the “newline character”) which skips to the next line. By replacing this with ' ' we keep things on the same line.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables and Data Types for Single Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html",
    "href": "05-data-types-part2.html",
    "title": "5  Data Types for Multiple Values",
    "section": "",
    "text": "5.1 Introduction\nIn Chapter 4 we learned about the int, float, str and bool data types, which all had single values. But we often have to deal with many values. For example, suppose you wanted to analyze the past daily sales of a company in recent years. It would not be very convenient to assign each of the hundreds of values of sales to different variables and work with them. Python has other data types available to deal with multiple values: lists, tuples, dictionaries, sets and frozen sets. These will be the focus of this chapter.\nIn later chapters we will also see that there are Python modules that have other data types. In this chapter we will focus on the data types that come built in.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#lists",
    "href": "05-data-types-part2.html#lists",
    "title": "5  Data Types for Multiple Values",
    "section": "5.2 Lists",
    "text": "5.2 Lists\nA very common way to store a sequence of values (which could be integers, floats, strings or Booleans), is in a list. You can create a list by putting the values in between square brackets, separated by commas:\n\na = [2, 4, 6]\na\n\n[2, 4, 6]\n\n\nLists can also be composed of floats, Booleans, or strings, or even a combination of them:\n\na = [1, 1.1, True, \"hello\"]\n\nLists can even have other lists as elements:\n\na = [1, 2, [3, 4]]\n\nAlthough we see 4 numbers, this list actually has only 3 elements:\n\nlen(a)\n\n3\n\n\nwhere the len() function returns the length of its argument. The [3, 4] is actually considered one element and is itself a list.\n\n5.2.1 List Operations\nIf we use the + operator on lists it just creates a longer list with one appended to the other:\n\na = [2, 4, 6]\nb = [8, 10]\na + b\n\n[2, 4, 6, 8, 10]\n\n\nIf we use the * operator it repeats the list:\n\na = [2, 4, 6]\na * 3 \n\n[2, 4, 6, 2, 4, 6, 2, 4, 6]\n\n\nWe cannot use the - and / operators on lists. In these ways lists behave like strings.\n\n\n5.2.2 List Indexing\nLists are ordered so the order in which we place the elements matters. To extract a particular value from a list based on its position in the list we can use a method called indexing. If I want the first element of the list I can extract it with a[0]:\n\na[0]\n\n2\n\n\nThe 0 here is the index. It means to take element 0 from the list. In Python and several other programming langauges (like C and C++), counting starts at 0 instead of 1. So element 0 is actually the 1st element. This is something that might take some getting used to, so be careful when using indexing.\nEven though the list has 3 elements, the last element is extracted with a[2]:\n\na[2]\n\n6\n\n\nIf you try to do a[3] you get an IndexError saying the list index is out of range.\nIndexing like this also works for strings, and many other objects with multiple values. For example, to get the first character in a string we can get the value at index 0:\n\na = 'hello'\na[0]\n\n'h'\n\n\nWe can also use indexing to change values in a list:\n\na = [2, 4, 6]\na[0] = 8\na\n\n[8, 4, 6]\n\n\nBecause lists have this property, we say they are mutable.\n\n\n5.2.3 List Slicing\nTo get all elements starting from 1 up to but not including index 3 (the 2nd and 3rd element) we can do:\n\na = [1, 2, 3, 4, 5]\na[1:3]\n\n[2, 3]\n\n\nTo get all elements starting from index 2 (the 3rd element onwards) we can do:\n\na[2:]\n\n[3, 4, 5]\n\n\nTo get all elements up to but not including index 2 (the 1st and 2nd element) we can do:\n\na[:2]\n\n[1, 2]\n\n\nFinally, the following just returns the original list:\n\na[:]\n\n[1, 2, 3, 4, 5]\n\n\n\n\n5.2.4 List Methods\nLists, like many objects in Python, have methods. A method in Python is like a function but instead of using the object as an argument to the function, we apply the function to the object. We’ll see what we mean by this with an example. Suppose we wanted to add another number to our list at the end, like the number 8. Instead of recreating the entire list with a = [2, 4, 6, 8], we can append 8 to the end of the list using the append() method. Methods are invoked by placing them after the object separated with a . like this:\n\na = [2, 4, 6]\na.append(8)\na\n\n[2, 4, 6, 8]\n\n\nNotice that we didn’t need to assign the output of append() to an object with =. It altered a in place. This is what the method does.\nTo remove an element from a list we can use the pop() method. For example, to remove the 2nd element (element with index 1), we can do:\n\na = [2, 4, 6]\na.pop(1)\na\n\n[2, 6]\n\n\nAnother list method is reverse() which reverses the ordering of the list:\n\na = [2, 4, 6]\na.reverse()\na\n\n[6, 4, 2]\n\n\nTo sort a list ascending we can use sort():\n\na = [1, 3, 2]\na.sort()\na\n\n[1, 2, 3]\n\n\n\n\n5.2.5 Iterating over Items in a List\nA useful feature of a list is that we can iterate over each element, performing the same operation or set of operations on each element one by one. For example, suppose we wanted to see what the square of each element in the list was. We can use what is called a for loop to do this. Here is how to code it:\n\na = [2, 4, 6, 8]\nfor i in a:\n    print(i ** 2)\n\n4\n16\n36\n64\n\n\nIn words, what is happening is “for all i in the list a, print i^2”. We use i as a sort of temporary variable for each element in a. The next line then prints i ** 2 which squares i. You will notice that the print() command is indented with 4 spaces. This is to tell Python that this command is part of the loop. When there is code under the for loop that is not indented, Python interprets this as not being part of the loop.\nTo understand this, compare the following two snippets, which are almost the same except the first print(\"hello\") is indented and the second is not:\n\na = [2, 4, 6, 8]\nfor i in a:\n    print(i ** 2)\n    print(\"hello\")\n\n4\nhello\n16\nhello\n36\nhello\n64\nhello\n\n\n\na = [2, 4, 6]\nfor i in a:\n    print(i ** 2)\nprint(\"hello\")\n\n4\n16\n36\nhello\n\n\nThe first code prints \"hello\" 3 times, and the second only once, even though the code looks almost the same except for the indentations. This is because in the first case, the indentation tells Python that that print() call is part of the loop. In each iteration of the loop, we have to print the square of i and print hello. The loop iterates 3 times, so we see \"hello\" 3 times.\nIn the second case, the lack of indentation tells Python that the print(\"hello\") is not in the loop. Python first finishes the loop (squaring each element of a and printing it). It only then gets to the next part of the code and prints \"hello\".\nTherefore it is very important to be careful with indentation with Python. You should indent with 4 spaces (not tabs) for content in a loop.\nAnother thing to note here is that a for loop is a situation where the code is no longer running line-by-line from top to bottom. The code goes to the end of the loop and if there are iterations remaining to be done it goes back to the start of the loop. Only when it has completed all the iterations does it go to the next line after the loop.\n\n\n5.2.6 List Comprehensions\nSuppose we wanted to save the square of each element of a into a new list called b. One way to do that would be to create an empty list called b with b = []. This is a list with no elements. Then we could use the for loop to append the values to b, like this:\n\na = [2, 4, 6]\nb = []\nfor i in a:\n  b.append(i ** 2)\nb\n\n[4, 16, 36]\n\n\nThis works just fine, but the code is a bit “clunky”. Moreover, if your list is very very large it would run very slowly. A cleaner and faster way to do this kind of operation is by using list comprehensions.\n\na = [2, 4, 6]\nb = [i ** 2 for i in a]\nb\n\n[4, 16, 36]\n\n\nThis is a very neat and compact way to create the new list. It also reads similar to how we would describe what is happening: “make a list which is i^2 for all elements i in the list a”.\n\n\n5.2.7 List Membership\nTo see if an element is contained somewhere in a list, we can use the in operator:\n\na = [2, 4, 6]\n4 in a\n\nTrue\n\n\n\n5 in a\n\nFalse\n\n\n4 is in a so we get True, but 5 is not so we get False.\n\n\n5.2.8 Copying Lists\nOne thing to note about lists, which may be unexpected, is that if we create a list a and set b = a, we are actually telling Python that a and b refer to the same object, not just that they have the same values. This has the consequence that if we change a that b will also change. For example:\n\na = [2, 4, 6]\nb = a\na[0] = 8\nb\n\n[8, 4, 6]\n\n\nWe set b = a but otherwise perform no operations on b. We change the first element of a (element 0) to 8, and the first element of b changes to 8 as well!\nOften when we are programming we don’t want this to happen. We often want to copy a list to a new one to perform some operations and leave the original list unchanged. What we can do instead is set b equal to a[:] instead of a. This way b won’t change when a changes:\n\na = [2, 4, 6]\nb = a[:]\na[0] = 8\nb\n\n[2, 4, 6]\n\n\nBecause there are two different ways of copying objects with different consequences, we have two different terms for them:\n\nDeep copy: This copies a to b and recursively copies all of its elements, resulting in a completely independent object.\nShallow copy: This copies a to b but does not recursively copy its elements. Instead it only copies the references to the elements in a (like the address for where in the computer’s memory those elements are stored). This means that changes to elements of a will affect the elements of b.\n\nThe b = a example is a shallow copy and the b = a[:] example is a deep copy.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#tuples",
    "href": "05-data-types-part2.html#tuples",
    "title": "5  Data Types for Multiple Values",
    "section": "5.3 Tuples",
    "text": "5.3 Tuples\nA tuple is another data type that is quite similar to a list. One important difference, however, is that they are immutable. We cannot change individual values of a tuple after they are created, and we cannot append values to a tuple.\nWe can create a tuple in Python using parentheses instead of square brackets:\n\na = (2, 4, 6)\n\nIndexing and many other operations that work for lists also work with tuples. We index them the same way as lists (using square brackets like a[0]) and we can iterate over the items with for loops in the same way. However the list of methods for tuples is much shorter. We cannot append or pop values because the tuples are immutable.\n\n5.3.1 Tuple Assignment\nOne useful thing we can do with tuples is tuple assignment. Suppose we have a list x = [\"a\", \"b\", \"c\"] and we wanted to create 3 objects from this: x_0 = \"a\", x_1 = \"b\" and x_2 = \"c\". One way to do this is:\n\nx = [\"a\", \"b\", \"c\"]\nx_0 = x[0]\nx_1 = x[1]\nx_2 = x[2]\n\nBut a much more elegant way to do this is using tuple assignment:\n\nx = [\"a\", \"b\", \"c\"]\n(x_0, x_1, x_2) = x\n\nThis assigns \"a\" to x_0, \"b\" to x_1 and \"c\" to x_2 all in one line.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#dictionaries",
    "href": "05-data-types-part2.html#dictionaries",
    "title": "5  Data Types for Multiple Values",
    "section": "5.4 Dictionaries",
    "text": "5.4 Dictionaries\nAnother common built-in data type is a dictionary. A dictionary maps keys to values, where the keys can be an immutable data type (usually an integer or string) and the values can be any type, for example, single values, lists, or tuples. For example, a company might have supplier IDs for its suppliers and a dictionary mapping those IDs to the actual company name.\nWe could create a simple dictionary like this as follows:\n\nsuppliers = {100001 : \"ABC Ltd.\", 100002 : \"EFG Ltd.\"}\n\nDictionaries are created within curly brackets. We can create an empty dictionary with {}:\n\ntype({})\n\ndict\n\n\nTo find a company name using the company ID we provide the key in the place we would supply an index for a list or tuple:\n\nsuppliers[100001]\n\n'ABC Ltd.'\n\n\nDictionaries are unordered, so we cannot do suppliers[0] to find the first supplier. There is no first value in a dictionary.\nWe can also add new keys and values to the dictionary:\n\nsuppliers[100003] = \"HIJ Ltd.\"\nsuppliers\n\n{100001: 'ABC Ltd.', 100002: 'EFG Ltd.', 100003: 'HIJ Ltd.'}\n\n\nWe can also modify values:\n\nsuppliers[100003] = \"KLM Ltd.\"\nsuppliers\n\n{100001: 'ABC Ltd.', 100002: 'EFG Ltd.', 100003: 'KLM Ltd.'}\n\n\nTo get all the keys in a dictionary we can use the keys() method:\n\nsuppliers.keys()\n\ndict_keys([100001, 100002, 100003])\n\n\nAnd to get all the values in a dictionary we can use the values() method:\n\nsuppliers.values()\n\ndict_values(['ABC Ltd.', 'EFG Ltd.', 'KLM Ltd.'])\n\n\nWe can also loop over keys in a dictionary the following way:\n\nfor key in suppliers:\n    print(\"Supplier with ID \" + str(key) + \" is \" + suppliers[key])\n\nSupplier with ID 100001 is ABC Ltd.\nSupplier with ID 100002 is EFG Ltd.\nSupplier with ID 100003 is KLM Ltd.\n\n\nUsing for with a dictionary implicitly iterates over the keys.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "05-data-types-part2.html#sets-and-frozen-sets",
    "href": "05-data-types-part2.html#sets-and-frozen-sets",
    "title": "5  Data Types for Multiple Values",
    "section": "5.5 Sets and Frozen Sets",
    "text": "5.5 Sets and Frozen Sets\nA set is another way to store multiple items into a single variable. Lists are unordered and unindexed. This means you cannot exract individual elements using their index like a list, nor by their key like a dictionary.\nYou can create a set by placing items (like integers or strings) inside curly brackets ({}) separated by commas:\n\nmyset = {\"apple\", \"banana\", \"cherry\"}\nmyset\n\n{'apple', 'banana', 'cherry'}\n\n\nSets cannot have duplicate items. It only keeps the unique values. For example, suppose we provide \"cherry\" twice:\n\nmyset = {\"apple\", \"banana\", \"cherry\", \"cherry\"}\nmyset\n\n{'apple', 'banana', 'cherry'}\n\n\nIt only keeps the first \"cherry\".\nYou are, however, able to add and remove elements to a set.\n\nmyset = {\"apple\", \"banana\", \"cherry\"}\nmyset.add(\"pear\")\nmyset\n\n{'apple', 'banana', 'cherry', 'pear'}\n\n\n\nmyset = {\"apple\", \"banana\", \"cherry\"}\nmyset.remove(\"apple\")\nmyset\n\n{'banana', 'cherry'}\n\n\nConverting a list to a set is useful if you want to get the list of unique elements:\n\nfruits = [\"apple\", \"apple\", \"apple\", \"banana\", \"cherry\", \"banana\"]\nset(fruits)\n\n{'apple', 'banana', 'cherry'}\n\n\nWe can iterate over sets just like lists (with for i in myset). We can also perform set operations on pairs of sets.\nFor example, for two sets A and B, we can find A\\cap B (the set of elements contained in both sets) using:\n\nset_a = {1, 2, 4, 6, 8, 9}\nset_b = {2, 3, 5, 7, 8}\nset_a.intersection(set_b)\n\n{2, 8}\n\n\nThe numbers 2 and 8 are the only numbers in both sets.\nTo find A\\cup B (the set of elements contained in either set) we can do:\n\nset_a.union(set_b)\n\n{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nThis gets all the numbers appearing in the two sets (dropping duplicates).\nTo find A\\setminus B (the set of elements in A not contained in B) we can do:\n\nset_a.difference(set_b)\n\n{1, 4, 6, 9}\n\n\n1, 4, 6 and 9 are in A and not in B. The number 2, for example, is not here because that is also in B.\nTo create a set that is immutable (so that you cannot add or remove items), you can use the frozenset() function:\n\nmyset = frozenset([1, 2, 3])\n\nYou can still use the same operations on frozensets as normal sets, except you cannot modify them once they are created.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types for Multiple Values</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html",
    "href": "06-defining-functions.html",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "",
    "text": "6.1 Introduction\nWe have used a number of Python functions so far, such as the absolute value function and the square root function. In this chapter we will learn how we can create our own functions. We will also learn how to use conditional statements inside functions.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#structure-of-a-function",
    "href": "06-defining-functions.html#structure-of-a-function",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.2 Structure of a Function",
    "text": "6.2 Structure of a Function\nWe will start off learning how to program a very basic function. Consider the function that returns its input plus one. Mathematically the function would be represented as:\n\nf(x)=x+1\n So f(0)=1, f(1)=2 and f(2)=3 and so on. In Python we can create this function with:\n\ndef addone(x):\n    y = x + 1\n    return y\n\nThe def tells Python we are creating a function. We then provide the functions name (here addone). After that we put in the function’s arguments in parentheses, separated by commas. Here there is only one argument so we just write x. Then like with a for loop we add a : and add the body of the function below it indented by 4 spaces. Here the only thing the function does is create y which is x + 1. We then get the function to return the output, which is y.\nLet’s try it out:\n\naddone(2)\n\n3\n\n\nWe get the expected output!\nOne thing to note about this function is that the y that is assigned x + 1 in the function is never stored in our environment. The y only exists within the function and is deleted after the function ends. We cannot access it outside. We say that y is a local variable (it is local to the function). It is possible to define global variables within a function that can accessed after the function is called, but for our purposes doing so is generally not very good practice and so we will not cover that here.\nWe could also shorten our code by doing the calculation on the same line as the return command:\n\ndef addone(x):\n    return x + 1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#commenting-in-python",
    "href": "06-defining-functions.html#commenting-in-python",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.3 Commenting in Python",
    "text": "6.3 Commenting in Python\nAs we start to write longer programs that include functions, it’s s good idea to start annotating your code to help other people understand its purpose (and also you when you look back at your own code after a couple of days!). We can do this by adding comments. In Python we can add a comment by using the # character. Everything after the # character is ignored by the Python interpreter, so what we write after it doesn’t need to be “legal” Python commands. We can add a comment to describe what a function does like this:\n\n# This function returns the input plus one:\ndef addone(x):\n    return x + 1\n\nWe can also add comments to the same line as code we want to run provided we put it after the command. Like this:\n\n2 ** 3  # this command calculates 2 to the power of 3\n\n8",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "06-defining-functions.html#conditional-execution",
    "href": "06-defining-functions.html#conditional-execution",
    "title": "6  Defining Functions and Conditional Execution",
    "section": "6.4 Conditional Execution",
    "text": "6.4 Conditional Execution\n\n6.4.1 If-Else Statements\nConditional statements, or “if-else statements”, are very useful and extremely common in programming. In an if-else statement, the code first checks a particular true/false condition. If the condition is true, it performs one action, and if the condition is false, it performs another action.\nA simple example of this is the absolute value function we saw in Chapter 3. Let’s define precisely what that function does:\n\n|x| = \\begin{cases}\n-x & \\text{ if } x &lt; 0 \\\\\nx & \\text{ otherwise}\n\\end{cases}\n\nIf x&lt;0 it returns -x, so that the negative number turns positive. Otherwise (if x=0 or it is positive), it keeps the value of x the same.\nAlthough Python already has an absolute value function (abs()), let’s create our own function (called my_abs()) that does the same thing. To do this we use conditional statements (if and else). Here’s how it works:\n\ndef my_abs(x):\n    if x &lt; 0:\n        y = -x\n    else:\n        y = x\n    return y\n\nThe function first checks if x&lt;0. If it is true, it performs the operation under if (sets y=-x) and skips past the else statement and returns y. If it is false (i.e. x \\not &lt; 0) then it skips past the operation under the if statement and instead does the operation under the else statement (sets y=x) before returning y.\nLet’s try it out using some different values:\n\n[my_abs(i) for i in [-2, 0, 3]]\n\n[2, 0, 3]\n\n\nJust like with the addone() function above we can shorten this function definition. We could alternatively do:\n\ndef my_abs(x):\n    if x &lt; 0:\n        return -x\n    else:\n        return x\n\nThe function first checks if x&lt;0. If it is true, it returns -x and ends. It doesn’t go any further. If x \\not &lt; 0 then it skips the operation under if and does the operation under else (returns x).\nThis gives the same output:\n\n[my_abs(i) for i in [-2, 0, 3]]\n\n[2, 0, 3]\n\n\nThis means the return part of a function doesn’t have to be at the end of a function. But you should be aware that once a function returns a value it does not continue executing the remaining statements.\nFor example, consider the following code:\n\ndef badaddone(x):\n    return x\n    y = x + 1\n    return y\n[badaddone(i) for i in [1, 2, 3]]\n\n[1, 2, 3]\n\n\nThis is very similar to the first addone() function we defined above. The only difference is that we write return x as the first command in the function’s body. Although at it sets y=x+1 and returns y, the output is always the same as the input. This is because the function returns x at the top, which means the rest of the function is never executed.\n\n\n6.4.2 If-Else If-Else Statements\nSometimes we want to do one thing if a certain condition holds, another thing if a different condition holds, and something else in the remaining cases. An example of this is the “sign” function, which tells you the sign in front of a value:\n\nsgn(x) = \\begin{cases}\n-1 & \\text{ if } x &lt; 0 \\\\\n0 & \\text{ if } x = 0 \\\\\n+1 & \\text{ otherwise} \\\\\n\\end{cases}\n If the value is negative, we get -1. If it’s zero we get 0. If it’s positive (the remaining case), we get +1.\nTo do this in Python, we could nest several if-else statements:\n\ndef sign(x):\n    if x &lt; 0:\n        return -1\n    else:\n        if x == 0:\n            return 0\n        else:\n            return 1\n[sign(i) for i in [-2, 0, 3]]\n\n[-1, 0, 1]\n\n\nThe function does the following:\n\nIf x&lt;0, return -1.\nOtherwise proceed to the next if-else:\n\nIf x=0, return 0.\nOtherwise (if x&gt;0), return 0.\n\n\nAlthough this works, this is quite complicated and difficult to follow. Some of the return statements are indented 4 times, for what should be such a simple function. For these kinds of situations we can make use of the elif statement. Here is an alternative way to make this function using elif:\n\ndef sign(x):\n    if x &lt; 0:\n        return -1\n    elif x == 0:\n        return 0\n    else:\n        return 1\n[sign(i) for i in [-2, 0, 3]]\n\n[-1, 0, 1]\n\n\nIn words, what the code does in this case is:\n\nIf the 1st check is true (x&lt;0), the function returns -1 and it done.\nIf the 1st check is false (x\\not &lt;0), the function checks x=0. If that is true it returns 0 and it done.\nIf the 1st and 2nd check are false (x\\not &lt;0 and x\\neq 0), the function returns 1 and it done.\n\nIt actually does exactly the same as the first code, but because there is less nesting it is easier to follow and is preferred (especially when you have even more conditions to check!).\n\n\n6.4.3 While Loops\nA while loop is another very common method in programming. A while loop repeats a set of commands whenever a certain condition is true. A while loop also makes it possible to run an infinite loop. To have the sequence of numbers 1, 2, 3, \\dots printed on your screen forever (or until you kill the program) you could do:\nx = 0\nwhile True:\n    x += 1\n    print(x)\nNote: the x += 1 here is a shorter way of writing x = x + 1. The operations -=, *= and /= also work like this - try them out!\nBecause True will always be True, the loop will just keep running forever, adding 1 each time. Eventually the numbers will get so big that x will show up as inf (infinity), but you would have to let the program run for a very long time before you saw that.\nA while loop is also useful if you want to repeat a loop until something happens, but you don’t know how many times you need to run it before that happens. One instance when this would occur is if you wanted to numerically approximate a mathematical equation with an iterative algorithm. You want to repeat the iterations until the output starts to stabilize to a certain tolerance (accuracy) level, but you don’t know in advance how many iterations this will take. Let’s take a look at an example of this now.\nThe example we will look at is the way the ancient Greeks used to approximate square roots. Suppose you wanted to find the square root of x. What the ancient Greeks did is start with an initial guess of this y_0, let’s say \\frac{x}{2}. You then find the updated guess y_1 according to the formula: \ny_1 = \\frac{1}{2} \\left( y_0 + \\frac{x}{y_0}\\right)\n When you have y_1 we can update this for a more accurate approximation with: \ny_2 = \\frac{1}{2} \\left( y_1 + \\frac{x}{y_1}\\right)\n To write this in generate terms, given an initial guess y_0, we update y_n, with n=1,2,\\dots according to: \ny_n = \\frac{1}{2} \\left( y_{n-1} + \\frac{x}{y_{n-1}}\\right)\n\nYou continue updating this way until y_n stops changing very much (for example it changes by less than 0.000001 in an interaction).\nLet’s work manually with this algorithm to see how well it works. Suppose we want the square root of 2 which we know is approximately equal to 1.414214. Let’s start with a guess y_0=\\frac{x}{2}=\\frac{2}{2}=1. This is quite far off the true 1.414214 but we’ll go with it anyway. We can update the guess with the formula:\n\ny_1 = \\frac{1}{2}\\left(y_0 + \\frac{x}{y_0}\\right) =\n\\frac{1}{2}\\left(1 + \\frac{2}{1}\\right) =1.5\n This is already a lot closer (0.0858 away). Let’s do the next approximation step:\n\ny_2 = \\frac{1}{2}\\left(y_1 + \\frac{x}{y_1}\\right) =\n\\frac{1}{2}\\left(1.5 + \\frac{2}{1.5}\\right) = 1.416667\n This is already pretty close (0.00245 way)! Let’s do one more:\n\ny_3 = \\frac{1}{2}\\left(y_2 + \\frac{x}{y_2}\\right) =\n\\frac{1}{2}\\left(1.416667 + \\frac{2}{1.416667}\\right) = 1.414216\n It’s now only 0.0000021 away from the precise answer! That might be close enough for most purposes, and we can always do another iteration to improve its accuracy.\nLet’s see how to code this in Python:\n\ndef my_sqrt(x, tol=0.000001):\n    # Arguments:\n    #  x   : number to take the square root of.\n    #  tol : tolerance level of algorithm.\n  \n    # Set initial guess:\n    y = x / 2\n  \n    # Initialize distance:\n    dist = tol + 1 \n    \n    # Update guesses until y changes by less than tol:\n    while dist &gt; tol:\n        # Previous guess:\n        y_old = y\n        # Update guess:\n        y = (y_old + x / y_old) / 2\n        # Calculate distance from last guess:\n        dist = abs(y - y_old)\n    return y\n\nWe have written a function that can take 2 arguments: x, the number we want to take the square root of, and tol, which is the tolerance level for how accurate our approximation should be (a lower number is more accurate). When we write tol=0.000001 in the function definition it means we say that 0.000001 is the default value for tol. If we don’t need to provide the argument it will use this value, but we can specify a different value.\nLet’s try it out. First using the default value:\n\nmy_sqrt(2)\n\n1.414213562373095\n\n\nWe get an approximation that is very close to math.sqrt(2):\n\nimport math\nmath.sqrt(2)\n\n1.4142135623730951\n\n\nCan we specify a looser tolerance as follows:\n\nmy_sqrt(2, 0.1)\n\n1.4166666666666665\n\n\nAs expected, this is less accurate.\nWe now talk about the code in the function. The function first sets y_0=\\frac{x}{2} as the initial guess. It also needs to set dist = tol + 1 because the while loop checks dist &gt; tol. For this check, dist needs to exist locally in the function (tol is created from the arguments). And for the while loop to run at least once the dist needs to be bigger than tol. This is why we add one. Inside the while loop then, because we want to compare how our guess changes we set y_old = y before setting the new y according to the approximation formula. Then we get the absolute value of the difference between the new and old guess. We then go back to the top of the loop and we check if dist is still bigger than tol. If it is, it repeats the steps again. If not the while loop terminates and we go to the next stage, where y is returned as the output.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Defining Functions and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html",
    "href": "07-intro-to-numpy.html",
    "title": "7  Introduction to Numpy",
    "section": "",
    "text": "7.1 Introduction\nPython’s built-in data types like lists and tuples are not particularly well-suited for mathematical operations. We will show three examples of computations that we often need to do, and we will see that using lists involves quite a lot of coding to get the tasks done. We will then see that numpy can do these tasks very efficiently.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Numpy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#three-example-problems",
    "href": "07-intro-to-numpy.html#three-example-problems",
    "title": "7  Introduction to Numpy",
    "section": "7.2 Three Example Problems",
    "text": "7.2 Three Example Problems\n\nExample 1\nFor the first example, suppose we have a list x of numbers and we want to double each of the elements. We can’t use 2 * x because as we learned in Chapter 5 that just repeats the list twice. We have to do something like:\n\nx = [2, 4, 8]\ny = []\nfor i in x:\n    y.append(2 * i)\ny\n\n[4, 8, 16]\n\n\nWe create an empty list y. We then loop over the elements of x and append two times the element to y. This is very clunky. A better way of doing this is using a list comprehension:\n\nx = [2, 4, 8]\n[2 * i for i in x]\n\n[4, 8, 16]\n\n\nBut this is still a bit clunky. We would prefer a method that can just do 2 * x and get the same output.\n\n\nExample 2\nAnother example computation that we often need to do is if we have two lists of numbers x and y with the same number of elements and and we want to multiply them by each other element-by-element. Mathematically, suppose we have two vectors of numbers \\boldsymbol{x} and \\boldsymbol{y}: \n\\begin{split}\n\\boldsymbol{x}&=\\left(x_1, x_2, \\dots, x_n\\right) \\\\\n\\boldsymbol{y}&=\\left(x_1, x_2, \\dots, x_n\\right) \\\\\n\\end{split}\n and we want to calculate \\boldsymbol{z} from this which is:\n\\boldsymbol{z}=\\left(x_1 \\times y_2, x_2 \\times y_2, \\dots, x_n \\times y_n\\right)\n We can’t do x * y. That would return an error. But we could do this using a for loop:\n\nx = [2, 4, 8]\ny = [3, 2, 2]\nz = []\nfor i in range(len(x)):\n    z.append(x[i] * y[i])\nz\n\n[6, 8, 16]\n\n\nBecause we want to loop over the elements of both x and y, we have to loop over the indices 0, 1, 2. We could have written for i in [0, 1, 2], but range(len(x)) does this for us automatically (which is very useful if we have a long list). To see better what range is doing we can do:\n\nlist(range(5))\n\n[0, 1, 2, 3, 4]\n\n\nWe can see it creates a list from 0 up to but not including the argument.\nWe can improve on this code slightly by using the zip() function, which combines several iterables into one iterable.\n\nx = [2, 4, 8]\ny = [3, 2, 2]\nz = []\nfor i, j in zip(x, y):\n    z.append(i * j)\nz\n\n[6, 8, 16]\n\n\nSimilarly we can use zip() to do the task with a list comprehension:\n\nx = [2, 4, 8]\ny = [3, 2, 2]\n[i * j for i, j in zip(x, y)]\n\n[6, 8, 16]\n\n\nEven though we have now shortened the command down to one line, this last solution is still pretty clunky and also quite complicated. We would prefer an operation where we can just do x * y.\n\n\nExample 3\nFor the last example, suppose we want to find the median of a list of numbers. Recall that if the length of the list of numbers is odd, then the median is just the number in the middle when we sort the numbers. If the length of the list of numbers is even, then the median is the average of the two numbers closest to the middle when we sort the numbers.\nWe could create our own function to do this:\n\ndef median(x):\n    y = sorted(x)\n    if len(y) % 2 == 0:\n        return (y[len(y) // 2 - 1] + y[len(y) // 2]) / 2\n    else:\n        return y[len(y) // 2]\n\nThe function first sorts the list. The sorted() function gives the sorted list as the output. We do this instead of x.sort() because otherwise the function would sort our input list globally which we may not want it to do. The if len(y) % 2 == 0: checks if the length of the list is even. If it is even it takes the average of the element with index len(y) // 2 - 1 (just left of the middle) and the element with index len(y) // 2 (just right of the middle). We use // to ensure the division returns an integer instead of a float. If the length of the list is odd it returns the element with index len(y) // 2. Because len(y) / 2 is not an integer when len(y) is odd we use // to round down.\nLet’s test it out:\n\nmedian([2, 6, 4])\n\n4\n\n\n\nmedian([2, 6, 4, 3])\n\n3.5\n\n\nWe get the expected ouptut. However, this is quite complicated. We wouldn’t want to have to code this function every time we wanted to do something as common as finding the median.\nWe will see that functions from the module numpy can solve each of these problems (and a lot more) very easily.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Numpy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#importing-numpy",
    "href": "07-intro-to-numpy.html#importing-numpy",
    "title": "7  Introduction to Numpy",
    "section": "7.3 Importing Numpy",
    "text": "7.3 Importing Numpy\nWe can import the numpy module using import numpy like with other modules. However it is conventional to load numpy the following way:\n\nimport numpy as np\n\nThis way we can use the functions from numpy with the shorter np instead of having to type numpy out in full every time. Doing this shortcut is okay because so many people do it that it’s easy for people to read. You can load other modules with shortcuts in a similar way, but you should follow the normal conventions when you can.\nNumpy works with arrays. We can create an array using numpy’s array function. Because we can shorten numpy to np, we can create an array with the function np.array() like this:\n\nimport numpy as np\nx = np.array([2, 4, 8])\nx\n\narray([2, 4, 8])\n\n\nYou will notice that even though we provided a list of integers, numpy converted these to floats. Numpy arrays always work with floats.\nWe will now show the power of numpy by doing all the previous examples with very little code.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Numpy</span>"
    ]
  },
  {
    "objectID": "07-intro-to-numpy.html#solving-the-example-problems-with-numpy",
    "href": "07-intro-to-numpy.html#solving-the-example-problems-with-numpy",
    "title": "7  Introduction to Numpy",
    "section": "7.4 Solving the Example Problems with Numpy",
    "text": "7.4 Solving the Example Problems with Numpy\n\nExample 1\nTo double every number in array:\n\nx = np.array([2, 4, 8])\n2 * x\n\narray([ 4,  8, 16])\n\n\n\n\nExample 2\nTo multiply the elements of two arrays element-by-element:\n\nx = np.array([2, 4, 8])\ny = np.array([3, 2, 2])\nx * y\n\narray([ 6,  8, 16])\n\n\n\n\nExample 3\nTo get the median of an array:\n\nx = np.array([2, 6, 4])\nnp.median(x)\n\n4.0\n\n\n\nx = [2, 6, 4, 3]\nnp.median(x)\n\n3.5\n\n\nThe np.median() function also works if we just provide a list instead of an np.array:\n\nnp.median([2, 6, 4, 3])\n\n3.5\n\n\nThese are just a few examples of how numpy can simplify coding drastically.\nFor many programming tasks we need to do, it’s very often many people had to do the same thing before. This means there is often a module available that can do the task. Of course we learn a lot from coding functions from scratch, but in order to complete a task quickly and efficiently it is often better to use the modules made for the task.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Numpy</span>"
    ]
  }
]